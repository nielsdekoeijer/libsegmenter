{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The <code>libsegmenter</code> audio segmentation library","text":"<p>A small library intended to provide helper functions for block-based processing  in Python. </p> <p>Find out more by exploring the code or reading  the docs.</p>"},{"location":"#about","title":"About","text":"<p>The main idea is to help the user choose a combination of window function and  hop size, which satisfy the constant-overlap-add (COLA) condition, i.e.,  if the processing does not modify the blocks, the act of segmenting and  un-segmenting the input audio data should be perfectly reconstructing  (with some potential latency introduced by the system).</p> <p>The library currently supports three  different modes of operation</p> <ul> <li> <p>Overlap-Add (<code>ola</code>), where a rectangular window is applied to the input      frames, and the specified window is applied to the output frames prior to      reconstruction. This mode is intended for block-based processing in the      time-domain, where the purposed of the overlapping windows is to      interpolate the discontinuities between adjacent frames prior to      reconstruction.</p> </li> <li> <p>Weighted Overlap-Add (<code>wola</code>), where a square-root (COLA)-window is applied      to both the input frame and output frame. This mode is intended for      processing in the frequency domain along the lines of Short-time Fourier      Transform (STFT) processing.</p> </li> <li> <p>Analysis (<code>analysis</code>), where a window is applied to the input frames and     disables computing output frames. Useful to obtain spectrograms.</p> </li> </ul> <p>The primary use-case for the library is to support machine learning tasks,  which has led to a number of options which are designed to ease training tasks. The segmenter is implemented in both TensorFlow and PyTorch to support multiple  machine learning tasks. </p> <p>Recently, we have upgraded the library to version 1.0. This deprecated the  C++ backend for now to simplify development. That being said, the general design has been simplified so implementing your own backend (and verifying it with our unit tests) should not be infeasible.</p>"},{"location":"#a-word-of-caution","title":"A word of caution","text":"<p>Note that segmentation is a destructive operation in the sense that we do not  provide any pre and post windows. This means that the first and last couple of samples of your audio post subsequently <code>segment</code>-ing and <code>unsegment</code>-ing are going to be  windowed, thus different than what you started out with.  This is something to take into account when training.</p>"},{"location":"#installation","title":"Installation","text":"<p>Simply install from PyPi:</p> <pre><code># base version\npip install libsegmenter\n\n# with torch\npip install libsegmenter[torch]\n\n# with tensorflow\npip install libsegmenter[tensorflow]\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>To create a specific window</p> <pre><code>import libsegmenter as seg\nwindow = seg.WindowSelector(\"hann75\", \"ola\", 1024)\nwindow.analysis_window  # numpy ndarray containing the analysis window\nwindow.synthesis_window # numpy ndarray containing the synthesis window\n</code></pre> <p>To make a segmenter with a specific window:</p> <pre><code>import libsegmenter as seg\nsegmenter = seg.Segmenter(seg.WindowSelector(\"hann75\", \"ola\", 1024), backend=\"torch\")\n</code></pre> <p>With an asymetric window:</p> <pre><code>import libsegmenter as seg\nsegmenter = seg.Segmenter(seg.AsymmetricWindowSelector(\"ola\", 1024, 128, 2048), backend=\"torch\")\n</code></pre> <p>Use various supported transforms:</p> <pre><code>import libsegmenter as seg\nsegmenter = seg.Segmenter(seg.WindowSelector(\"hann75\", \"ola\", 1024), backend=\"torch\")\ntransform = seg.TransformSelector(transform=\"spectrogram\", backend=\"torch\")\nX = transform.forward(segmenter.segment(x))\nx = transform.inverse(x)\n</code></pre>"},{"location":"#development","title":"Development","text":""},{"location":"#installing-python","title":"Installing python","text":"<p>Install <code>uv</code> (pip replacement):</p> <pre><code># install for linux / mac\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# install for windows\npowershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre> <p>Install the development packages:</p> <pre><code>uv venv\nsource .venv/bin/activate\nuv sync --dev\n</code></pre>"},{"location":"#linting","title":"Linting","text":"<p>We require everything to be fully typed. We enforce that by having 100% clearance on pyright:</p> <pre><code>uv run pyright\nuv run ruff check\nuv run ruff format\n</code></pre>"},{"location":"#licenses","title":"Licenses","text":"<p>The project is licensed under MIT. Add licenses using the <code>addlicense</code> tool found here:</p> <pre><code>addlicense -c \"Niels de Koeijer, Martin Bo M\u00f8ller\" -l mit -y 2025 -ignore *.m\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>Docs are mainly automatically generated and described with docstrings. To host the docs locally run:</p> <pre><code>mkdocs serve\n</code></pre> <p>They are automatically rebuilt on push to main.</p>"},{"location":"api/AsymmetricWindowSelector/","title":"AsymmetricWindowSelector","text":""},{"location":"api/AsymmetricWindowSelector/#libsegmenter.AsymmetricWindowSelector.AsymmetricWindowSelector","title":"<code>AsymmetricWindowSelector(scheme, analysis_segment_size, hop_size, synthesis_segment_size)</code>","text":"<p>Designs an asymmetric Hann window pair based on the given parameters.</p> <p>This function retrieves a window function based on the <code>window</code> type, applies an adaptation based on <code>scheme</code>, and returns the corresponding <code>Window</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>scheme</code> <code>str</code> <p>The adaptation scheme to use. Supported values: [  <code>ola</code>,  <code>wola</code>, ]</p> required <code>analysis_segment_size</code> <code>int</code> <p>The size of the segment / analysis_window.</p> required <code>hop_size</code> <code>int</code> <p>The hop size used for segmentation.</p> required <code>synthesis_segment_size</code> <code>int</code> <p>The non-zero size of the systhesis_window.</p> required <p>Returns:</p> Name Type Description <code>Window</code> <code>Window</code> <p>A <code>Window</code> object containing the selected window function and its corresponding hop size.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unknown window type or scheme is provided.</p> Source code in <code>src/libsegmenter/AsymmetricWindowSelector.py</code> <pre><code>def AsymmetricWindowSelector(\n    scheme: str,\n    analysis_segment_size: int,\n    hop_size: int,\n    synthesis_segment_size: int,\n) -&gt; Window:\n    \"\"\"\n    Designs an asymmetric Hann window pair based on the given parameters.\n\n    This function retrieves a window function based on the `window` type, applies\n    an adaptation based on `scheme`, and returns the corresponding `Window` object.\n\n    Args:\n        scheme (str): The adaptation scheme to use. Supported values:\n            [\n             `ola`,\n             `wola`,\n            ]\n        analysis_segment_size (int): The size of the segment / analysis_window.\n        hop_size (int): The hop size used for segmentation.\n        synthesis_segment_size (int): The non-zero size of the systhesis_window.\n\n    Returns:\n        Window: A `Window` object containing the selected window function and its\n            corresponding hop size.\n\n    Raises:\n        ValueError: If an unknown window type or scheme is provided.\n\n    \"\"\"\n    if analysis_segment_size % hop_size != 0:\n        raise ValueError(\n            \"The analysis_segment_size must be integer divisible by hop_size.\"\n            + f\" Received analysis_segment_size = '{analysis_segment_size}' \"\n            + f\" and hop_size = '{hop_size}'.\"\n        )\n    if synthesis_segment_size % hop_size != 0:\n        raise ValueError(\n            \"The synthesis_segment_size must be integer divisible by hop_size.\"\n            + f\" Received synthesis_segment_size = '{synthesis_segment_size}' \"\n            + f\" and hop_size = '{hop_size}'.\"\n        )\n    if scheme != \"ola\" and scheme != \"wola\":\n        raise ValueError(f\"The '{scheme}' scheme is not supported.\")\n\n    elif scheme == \"ola\":\n        from libsegmenter.windows.hann import asymmetricHannOla\n\n        windows = asymmetricHannOla(\n            analysis_segment_size, hop_size, synthesis_segment_size\n        )\n\n    else:  # WOLA\n        from libsegmenter.windows.hann import asymmetricHannWola\n\n        windows = asymmetricHannWola(\n            analysis_segment_size, hop_size, synthesis_segment_size\n        )\n\n    analysis_window = windows[0]\n    synthesis_window = windows[1]\n    window = np.multiply(analysis_window, synthesis_window)\n\n    is_cola, normalization, e = check_cola(window, hop_size)\n    assert is_cola, f\"specified window failed cola check with error {e}\"\n\n    synthesis_window = np.divide(synthesis_window, normalization)\n\n    return Window(hop_size, analysis_window, synthesis_window)\n</code></pre>"},{"location":"api/Segmenter/","title":"Segmenter","text":""},{"location":"api/Segmenter/#libsegmenter.Segmenter.Segmenter","title":"<code>Segmenter(*args, backend='numpy', **kwargs)</code>","text":"<p>Factory function to create a segmenter instance based on the specified backend.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>str</code> <p>The backend to use. Supported options: [\"numpy\", \"torch\", \"tensorflow\"]. Defaults to \"numpy\".</p> <code>'numpy'</code> <code>*args</code> <code>Any</code> <p>Additional positional arguments to pass to the segmenter.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to the segmenter.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>An instance of the segmenter corresponding to the chosen backend.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unsupported backend or scheme is specified.</p> <code>NotImplementedError</code> <p>If the backend or scheme is not implemented.</p> Source code in <code>src/libsegmenter/Segmenter.py</code> <pre><code>def Segmenter(*args: Any, backend: str = \"numpy\", **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Factory function to create a segmenter instance based on the specified backend.\n\n    Args:\n        backend (str, optional): The backend to use. Supported options:\n            [\"numpy\", \"torch\", \"tensorflow\"]. Defaults to \"numpy\".\n        *args (Any): Additional positional arguments to pass to the segmenter.\n        **kwargs (Any): Additional keyword arguments to pass to the segmenter.\n\n    Returns:\n        An instance of the segmenter corresponding to the chosen backend.\n\n    Raises:\n        ValueError: If an unsupported backend or scheme is specified.\n        NotImplementedError: If the backend or scheme is not implemented.\n\n    \"\"\"\n    if backend not in BACKENDS:\n        raise ValueError(f\"Unsupported backend {backend}, availible: {BACKENDS}\")\n\n    if backend == \"numpy\":\n        from libsegmenter.backends.SegmenterNumpy import SegmenterNumpy\n\n        return SegmenterNumpy(*args, **kwargs)\n\n    if backend == \"torch\":\n        from libsegmenter.backends.SegmenterTorch import SegmenterTorch\n\n        return SegmenterTorch(*args, **kwargs)\n\n    if backend == \"tensorflow\":\n        from libsegmenter.backends.SegmenterTensorFlow import SegmenterTensorFlow\n\n        return SegmenterTensorFlow(*args, **kwargs)\n\n    raise NotImplementedError(f\"The '{backend}' backend is not implemented yet.\")\n</code></pre>"},{"location":"api/TransformSelector/","title":"TransformSelector","text":""},{"location":"api/TransformSelector/#libsegmenter.TransformSelector.TransformSelector","title":"<code>TransformSelector(transform, backend='numpy', *args, **kwargs)</code>","text":"<p>Factory function to create a transform instance based on the specified backend.</p> <p>Parameters:</p> Name Type Description Default <code>transform</code> <code>str</code> <p>The transform to use. Supported options: [\"bpd\", \"magnitude_phase\", \"spectrogram\"].</p> required <code>backend</code> <code>str</code> <p>The backend to use. Supported options: [\"numpy\", \"torch\", \"tensorflow\"]. Defaults to \"numpy\".</p> <code>'numpy'</code> <code>*args</code> <code>Any</code> <p>Additional positional arguments to pass to the segmenter.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to the segmenter.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>An instance of the transform corresponding to the chosen backend.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unsupported backend is specified.</p> <code>NotImplementedError</code> <p>If the backend is not implemented.</p> Source code in <code>src/libsegmenter/TransformSelector.py</code> <pre><code>def TransformSelector(\n    transform: str, backend: str = \"numpy\", *args: Any, **kwargs: Any\n) -&gt; Any:\n    \"\"\"\n    Factory function to create a transform instance based on the specified backend.\n\n    Args:\n        transform (str): The transform to use. Supported options:\n            [\"bpd\", \"magnitude_phase\", \"spectrogram\"].\n        backend (str, optional): The backend to use. Supported options:\n            [\"numpy\", \"torch\", \"tensorflow\"]. Defaults to \"numpy\".\n        *args (Any): Additional positional arguments to pass to the segmenter.\n        **kwargs (Any): Additional keyword arguments to pass to the segmenter.\n\n    Returns:\n        An instance of the transform corresponding to the chosen backend.\n\n    Raises:\n        ValueError: If an unsupported backend is specified.\n        NotImplementedError: If the backend is not implemented.\n\n    \"\"\"\n    if transform == \"spectrogram\":\n        from libsegmenter.transforms.Spectrogram import Spectrogram\n\n        return Spectrogram(*args, **kwargs, backend=backend)\n\n    if transform == \"magnitude_phase\":\n        from libsegmenter.transforms.MagnitudePhase import MagnitudePhase\n\n        return MagnitudePhase(*args, **kwargs, backend=backend)\n\n    if transform == \"bpd\":\n        from libsegmenter.transforms.BPD import BPD\n\n        return BPD(*args, **kwargs, backend=backend)\n\n    raise ValueError(f\"The '{transform}' transform is not known.\")\n</code></pre>"},{"location":"api/Window/","title":"Window","text":""},{"location":"api/Window/#libsegmenter.Window.Window","title":"<code>Window</code>","text":"<p>A class representing a windowing scheme used in signal segmentation.</p> <p>Attributes:</p> Name Type Description <code>hop_size</code> <code>int</code> <p>The step size for shifting the window in the segmentation process.</p> <code>analysis_window</code> <code>NDArray[T]</code> <p>The window function used during the analysis phase.</p> <code>synthesis_window</code> <code>NDArray[T]</code> <p>The window function used during the synthesis phase.</p> Source code in <code>src/libsegmenter/Window.py</code> <pre><code>class Window:\n    \"\"\"\n    A class representing a windowing scheme used in signal segmentation.\n\n    Attributes:\n        hop_size (int): The step size for shifting the window in the segmentation\n            process.\n        analysis_window (NDArray[T]): The window function used during the analysis\n            phase.\n        synthesis_window (NDArray[T]): The window function used during the synthesis\n            phase.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        hop_size: int,\n        analysis_window: NDArray[T],\n        synthesis_window: NDArray[T] | None,\n    ) -&gt; None:\n        \"\"\"\n        Initializes the Window instance with the specified hop size and windows.\n\n        Args:\n            hop_size (int): The step size for shifting the window in the segmentation\n                process.\n            analysis_window (NDArray[T]): The window function applied during analysis.\n            synthesis_window (NDArray[T] | None): The window function applied during\n                synthesis.\n\n        \"\"\"\n        if hop_size &lt;= 0 or hop_size &gt; analysis_window.shape[-1]:\n            raise ValueError(\n                \"Hop size argument must be between 1 and the length of the window. \"\n                + \"Received hop size = \"\n                + f\"({hop_size}) while the window size is \"\n                + f\"({analysis_window.shape[-1]}).\"\n            )\n        if synthesis_window is not None:\n            if analysis_window.shape[-1] != synthesis_window.shape[-1]:\n                raise ValueError(\n                    \"The analysis and synthesis windows must be of equal lengths. \"\n                    + \"Received analysis window length = \"\n                    + f\"({analysis_window.shape[-1]}) and synthesis window length = \"\n                    + f\"({synthesis_window.shape[-1]}).\"\n                )\n        self.hop_size = hop_size\n        self.analysis_window = analysis_window\n        self.synthesis_window = synthesis_window\n</code></pre>"},{"location":"api/Window/#libsegmenter.Window.Window.__init__","title":"<code>__init__(hop_size, analysis_window, synthesis_window)</code>","text":"<p>Initializes the Window instance with the specified hop size and windows.</p> <p>Parameters:</p> Name Type Description Default <code>hop_size</code> <code>int</code> <p>The step size for shifting the window in the segmentation process.</p> required <code>analysis_window</code> <code>NDArray[T]</code> <p>The window function applied during analysis.</p> required <code>synthesis_window</code> <code>NDArray[T] | None</code> <p>The window function applied during synthesis.</p> required Source code in <code>src/libsegmenter/Window.py</code> <pre><code>def __init__(\n    self,\n    hop_size: int,\n    analysis_window: NDArray[T],\n    synthesis_window: NDArray[T] | None,\n) -&gt; None:\n    \"\"\"\n    Initializes the Window instance with the specified hop size and windows.\n\n    Args:\n        hop_size (int): The step size for shifting the window in the segmentation\n            process.\n        analysis_window (NDArray[T]): The window function applied during analysis.\n        synthesis_window (NDArray[T] | None): The window function applied during\n            synthesis.\n\n    \"\"\"\n    if hop_size &lt;= 0 or hop_size &gt; analysis_window.shape[-1]:\n        raise ValueError(\n            \"Hop size argument must be between 1 and the length of the window. \"\n            + \"Received hop size = \"\n            + f\"({hop_size}) while the window size is \"\n            + f\"({analysis_window.shape[-1]}).\"\n        )\n    if synthesis_window is not None:\n        if analysis_window.shape[-1] != synthesis_window.shape[-1]:\n            raise ValueError(\n                \"The analysis and synthesis windows must be of equal lengths. \"\n                + \"Received analysis window length = \"\n                + f\"({analysis_window.shape[-1]}) and synthesis window length = \"\n                + f\"({synthesis_window.shape[-1]}).\"\n            )\n    self.hop_size = hop_size\n    self.analysis_window = analysis_window\n    self.synthesis_window = synthesis_window\n</code></pre>"},{"location":"api/WindowSelector/","title":"WindowSelector","text":""},{"location":"api/WindowSelector/#libsegmenter.WindowSelector.WindowSelector","title":"<code>WindowSelector(window, scheme, segment_size)</code>","text":"<p>Selects and returns a specific window function based on the given parameters.</p> <p>This function retrieves a window function based on the <code>window</code> type, applies an adaptation based on <code>scheme</code>, and returns the corresponding <code>Window</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>window</code> <code>str</code> <p>The type of window function to apply. Supported values include: [  <code>bartlett50</code>,  <code>bartlett75</code>,  <code>blackman67</code>,  <code>kaiser85</code>,  <code>hamming50</code>,  <code>hamming75</code>,  <code>hann50</code>,  <code>hann75</code>,  <code>rectangular0</code> ]</p> required <code>scheme</code> <code>str</code> <p>The adaptation scheme to use. Supported values: [  <code>ola</code>,  <code>wola</code>,  <code>analysis</code> ]</p> required <code>segment_size</code> <code>int</code> <p>The size of the segment/window.</p> required <p>Returns:</p> Name Type Description <code>Window</code> <code>Window</code> <p>A <code>Window</code> object containing the selected window function and its corresponding hop size.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unknown window type or scheme is provided.</p> Source code in <code>src/libsegmenter/WindowSelector.py</code> <pre><code>def WindowSelector(window: str, scheme: str, segment_size: int) -&gt; Window:\n    \"\"\"\n    Selects and returns a specific window function based on the given parameters.\n\n    This function retrieves a window function based on the `window` type, applies\n    an adaptation based on `scheme`, and returns the corresponding `Window` object.\n\n    Args:\n        window (str): The type of window function to apply. Supported values include:\n            [\n             `bartlett50`,\n             `bartlett75`,\n             `blackman67`,\n             `kaiser85`,\n             `hamming50`,\n             `hamming75`,\n             `hann50`,\n             `hann75`,\n             `rectangular0`\n            ]\n        scheme (str): The adaptation scheme to use. Supported values:\n            [\n             `ola`,\n             `wola`,\n             `analysis`\n            ]\n        segment_size (int): The size of the segment/window.\n\n    Returns:\n        Window: A `Window` object containing the selected window function and its\n            corresponding hop size.\n\n    Raises:\n        ValueError: If an unknown window type or scheme is provided.\n\n    \"\"\"\n    if window == \"bartlett50\":\n        from libsegmenter.windows.bartlett import bartlett50\n\n        return _adapt_window(*bartlett50(segment_size), scheme)\n\n    if window == \"bartlett75\":\n        from libsegmenter.windows.bartlett import bartlett75\n\n        return _adapt_window(*bartlett75(segment_size), scheme)\n\n    if window == \"blackman67\":\n        from libsegmenter.windows.blackman import blackman67\n\n        return _adapt_window(*blackman67(segment_size), scheme)\n\n    if window == \"kaiser85\":\n        from libsegmenter.windows.kaiser import kaiser85\n\n        return _adapt_window(*kaiser85(segment_size), scheme)\n\n    if window == \"hamming50\":\n        from libsegmenter.windows.hamming import hamming50\n\n        return _adapt_window(*hamming50(segment_size), scheme)\n\n    if window == \"hamming75\":\n        from libsegmenter.windows.hamming import hamming75\n\n        return _adapt_window(*hamming75(segment_size), scheme)\n\n    if window == \"hann50\":\n        from libsegmenter.windows.hann import hann50\n\n        return _adapt_window(*hann50(segment_size), scheme)\n\n    if window == \"hann75\":\n        from libsegmenter.windows.hann import hann75\n\n        return _adapt_window(*hann75(segment_size), scheme)\n\n    if window == \"rectangular0\":\n        from libsegmenter.windows.rectangular import rectangular0\n\n        return _adapt_window(*rectangular0(segment_size), scheme)\n\n    if window == \"rectangular50\":\n        from libsegmenter.windows.rectangular import rectangular50\n\n        return _adapt_window(*rectangular50(segment_size), scheme)\n\n    raise ValueError(f\"The '{window}' window is not known.\")\n</code></pre>"},{"location":"api/backends/SegmenterNumpy/","title":"SegmenterNumpy","text":""},{"location":"api/backends/SegmenterNumpy/#libsegmenter.backends.SegmenterNumpy.SegmenterNumpy","title":"<code>SegmenterNumpy</code>","text":"<p>A class for segmenting and reconstructing input data using windowing techniques.</p> <p>Supports Weighted Overlap-Add (WOLA) and Overlap-Add (OLA) methods.</p> <p>Attributes:</p> Name Type Description <code>window</code> <code>Window</code> <p>A class containing hop size, segment size, and windows.</p> Source code in <code>src/libsegmenter/backends/SegmenterNumpy.py</code> <pre><code>class SegmenterNumpy:\n    \"\"\"\n    A class for segmenting and reconstructing input data using windowing techniques.\n\n    Supports Weighted Overlap-Add (WOLA) and Overlap-Add (OLA) methods.\n\n    Attributes:\n        window (Window): A class containing hop size, segment size, and windows.\n\n    \"\"\"\n\n    def __init__(self, window: Window) -&gt; None:\n        \"\"\"\n        Initializes the SegmenterNumpy instance.\n\n        Args:\n            window (Window): A window object containing segmentation parameters.\n\n        \"\"\"\n        self.window = window\n\n    def segment(self, x: NDArray[T]) -&gt; NDArray[T]:\n        \"\"\"\n        Segments the input signal into overlapping windows using the window parameters.\n\n        Args:\n            x (np.ndarray): Input array, either 1D (sequence) or 2D (batch).\n\n        Returns:\n            Segmented data of shape (batch_size, num_segments, segment_size).\n\n        Raises:\n            ValueError: If types are incorrect.\n            ValueError: If input dimensions are invalid.\n\n        \"\"\"\n        if x.ndim not in {1, 2}:\n            raise ValueError(f\"Only supports 1D or 2D inputs, provided {x.ndim}D.\")\n\n        batch_size = x.shape[0] if x.ndim == 2 else None\n        num_samples = x.shape[-1]\n\n        if batch_size is None:\n            x = x.reshape(1, -1)  # Convert to batch format for consistency\n\n        num_segments = compute_num_segments(\n            num_samples, self.window.hop_size, self.window.analysis_window.shape[-1]\n        )\n\n        if num_segments &lt;= 0:\n            raise ValueError(\n                \"Input signal is too short for segmentation with the given num_samples \"\n                + f\"({num_samples}), hop size \"\n                + f\"({self.window.hop_size}) and segment size \"\n                + f\"({self.window.analysis_window.shape[-1]}).\"\n            )\n\n        # Pre-allocation\n        y = np.zeros(\n            (\n                batch_size if batch_size is not None else 1,\n                num_segments,\n                self.window.analysis_window.shape[-1],\n            ),\n            dtype=x.dtype,\n        )\n\n        # Windowing\n        for k in range(num_segments):\n            start_idx = k * self.window.hop_size\n            y[:, k, :] = np.multiply(\n                x[:, start_idx : start_idx + self.window.analysis_window.shape[-1]],\n                self.window.analysis_window,\n            )\n\n        return y.squeeze(0) if batch_size is None else y\n\n    def unsegment(self, y: NDArray[T]) -&gt; NDArray[T]:\n        \"\"\"\n        Reconstructs the original signal from segmented data using synthesis windowing.\n\n        Args:\n            y (np.ndarray): Segmented data with shape (batch_size, num_segments,\n                            segment_size) or (num_segments, segment_size) for a single\n                            sequence.\n\n        Returns:\n            Reconstructed signal.\n\n        \"\"\"\n        if self.window.synthesis_window is None:\n            raise ValueError(\"Given windowing scheme does not support unsegmenting.\")\n\n        if y.ndim not in {2, 3}:\n            raise ValueError(f\"Only supports 2D or 3D inputs, provided {y.ndim}D.\")\n\n        batch_size = y.shape[0] if y.ndim == 3 else None\n        num_segments = y.shape[-2]\n        segment_size = y.shape[-1]\n\n        if batch_size is None:\n            y = y.reshape(1, num_segments, -1)  # Convert to batch format\n\n        num_samples = compute_num_samples(\n            num_segments, self.window.hop_size, segment_size\n        )\n\n        if num_samples &lt;= 0:\n            raise ValueError(\n                \"Invalid segment structure, possibly due to incorrect windowing \"\n                + \"parameters.\"\n            )\n\n        # Efficient numpy array allocation\n        x = np.zeros(\n            (batch_size if batch_size is not None else 1, num_samples), dtype=y.dtype\n        )\n\n        # Vectorized accumulation\n        for k in range(num_segments):\n            start_idx = k * self.window.hop_size\n            x[:, start_idx : start_idx + segment_size] += np.multiply(\n                y[:, k, :], self.window.synthesis_window\n            )\n\n        return x.squeeze(0) if batch_size is None else x\n</code></pre>"},{"location":"api/backends/SegmenterNumpy/#libsegmenter.backends.SegmenterNumpy.SegmenterNumpy.__init__","title":"<code>__init__(window)</code>","text":"<p>Initializes the SegmenterNumpy instance.</p> <p>Parameters:</p> Name Type Description Default <code>window</code> <code>Window</code> <p>A window object containing segmentation parameters.</p> required Source code in <code>src/libsegmenter/backends/SegmenterNumpy.py</code> <pre><code>def __init__(self, window: Window) -&gt; None:\n    \"\"\"\n    Initializes the SegmenterNumpy instance.\n\n    Args:\n        window (Window): A window object containing segmentation parameters.\n\n    \"\"\"\n    self.window = window\n</code></pre>"},{"location":"api/backends/SegmenterNumpy/#libsegmenter.backends.SegmenterNumpy.SegmenterNumpy.segment","title":"<code>segment(x)</code>","text":"<p>Segments the input signal into overlapping windows using the window parameters.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Input array, either 1D (sequence) or 2D (batch).</p> required <p>Returns:</p> Type Description <code>NDArray[T]</code> <p>Segmented data of shape (batch_size, num_segments, segment_size).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If types are incorrect.</p> <code>ValueError</code> <p>If input dimensions are invalid.</p> Source code in <code>src/libsegmenter/backends/SegmenterNumpy.py</code> <pre><code>def segment(self, x: NDArray[T]) -&gt; NDArray[T]:\n    \"\"\"\n    Segments the input signal into overlapping windows using the window parameters.\n\n    Args:\n        x (np.ndarray): Input array, either 1D (sequence) or 2D (batch).\n\n    Returns:\n        Segmented data of shape (batch_size, num_segments, segment_size).\n\n    Raises:\n        ValueError: If types are incorrect.\n        ValueError: If input dimensions are invalid.\n\n    \"\"\"\n    if x.ndim not in {1, 2}:\n        raise ValueError(f\"Only supports 1D or 2D inputs, provided {x.ndim}D.\")\n\n    batch_size = x.shape[0] if x.ndim == 2 else None\n    num_samples = x.shape[-1]\n\n    if batch_size is None:\n        x = x.reshape(1, -1)  # Convert to batch format for consistency\n\n    num_segments = compute_num_segments(\n        num_samples, self.window.hop_size, self.window.analysis_window.shape[-1]\n    )\n\n    if num_segments &lt;= 0:\n        raise ValueError(\n            \"Input signal is too short for segmentation with the given num_samples \"\n            + f\"({num_samples}), hop size \"\n            + f\"({self.window.hop_size}) and segment size \"\n            + f\"({self.window.analysis_window.shape[-1]}).\"\n        )\n\n    # Pre-allocation\n    y = np.zeros(\n        (\n            batch_size if batch_size is not None else 1,\n            num_segments,\n            self.window.analysis_window.shape[-1],\n        ),\n        dtype=x.dtype,\n    )\n\n    # Windowing\n    for k in range(num_segments):\n        start_idx = k * self.window.hop_size\n        y[:, k, :] = np.multiply(\n            x[:, start_idx : start_idx + self.window.analysis_window.shape[-1]],\n            self.window.analysis_window,\n        )\n\n    return y.squeeze(0) if batch_size is None else y\n</code></pre>"},{"location":"api/backends/SegmenterNumpy/#libsegmenter.backends.SegmenterNumpy.SegmenterNumpy.unsegment","title":"<code>unsegment(y)</code>","text":"<p>Reconstructs the original signal from segmented data using synthesis windowing.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>ndarray</code> <p>Segmented data with shape (batch_size, num_segments,             segment_size) or (num_segments, segment_size) for a single             sequence.</p> required <p>Returns:</p> Type Description <code>NDArray[T]</code> <p>Reconstructed signal.</p> Source code in <code>src/libsegmenter/backends/SegmenterNumpy.py</code> <pre><code>def unsegment(self, y: NDArray[T]) -&gt; NDArray[T]:\n    \"\"\"\n    Reconstructs the original signal from segmented data using synthesis windowing.\n\n    Args:\n        y (np.ndarray): Segmented data with shape (batch_size, num_segments,\n                        segment_size) or (num_segments, segment_size) for a single\n                        sequence.\n\n    Returns:\n        Reconstructed signal.\n\n    \"\"\"\n    if self.window.synthesis_window is None:\n        raise ValueError(\"Given windowing scheme does not support unsegmenting.\")\n\n    if y.ndim not in {2, 3}:\n        raise ValueError(f\"Only supports 2D or 3D inputs, provided {y.ndim}D.\")\n\n    batch_size = y.shape[0] if y.ndim == 3 else None\n    num_segments = y.shape[-2]\n    segment_size = y.shape[-1]\n\n    if batch_size is None:\n        y = y.reshape(1, num_segments, -1)  # Convert to batch format\n\n    num_samples = compute_num_samples(\n        num_segments, self.window.hop_size, segment_size\n    )\n\n    if num_samples &lt;= 0:\n        raise ValueError(\n            \"Invalid segment structure, possibly due to incorrect windowing \"\n            + \"parameters.\"\n        )\n\n    # Efficient numpy array allocation\n    x = np.zeros(\n        (batch_size if batch_size is not None else 1, num_samples), dtype=y.dtype\n    )\n\n    # Vectorized accumulation\n    for k in range(num_segments):\n        start_idx = k * self.window.hop_size\n        x[:, start_idx : start_idx + segment_size] += np.multiply(\n            y[:, k, :], self.window.synthesis_window\n        )\n\n    return x.squeeze(0) if batch_size is None else x\n</code></pre>"},{"location":"api/backends/SegmenterTensorFlow/","title":"SegmenterTensorFlow","text":""},{"location":"api/backends/SegmenterTensorFlow/#libsegmenter.backends.SegmenterTensorFlow.SegmenterTensorFlow","title":"<code>SegmenterTensorFlow</code>","text":"<p>               Bases: <code>Layer</code></p> <p>A TensorFlow-based segmenter for input data using windowing techniques.</p> <p>Supports Weighted Overlap-Add (WOLA) and Overlap-Add (OLA) methods.</p> <p>Attributes:</p> Name Type Description <code>window</code> <code>Window</code> <p>A class containing hop size, and windows.</p> Source code in <code>src/libsegmenter/backends/SegmenterTensorFlow.py</code> <pre><code>class SegmenterTensorFlow(tf.keras.layers.Layer):\n    \"\"\"\n    A TensorFlow-based segmenter for input data using windowing techniques.\n\n    Supports Weighted Overlap-Add (WOLA) and Overlap-Add (OLA) methods.\n\n    Attributes:\n        window (Window): A class containing hop size, and windows.\n\n    \"\"\"\n\n    def __init__(self, window: Window) -&gt; None:\n        \"\"\"\n        Initializes the SegmenterTensorFlow instance.\n\n        Args:\n            window (Window): A window object containing segmentation parameters.\n\n        \"\"\"\n        super(SegmenterTensorFlow, self).__init__()  # type: ignore\n\n        self.window = window\n\n    def segment(self, x: tf.Tensor) -&gt; tf.Tensor:\n        \"\"\"\n        Segments the input tensor into overlapping windows.\n\n        Args:\n            x (tf.Tensor): Input tensor (1D or 2D).\n\n        Returns:\n            Segmented tensor of shape (batch_size, num_segments, segment_size).\n\n        \"\"\"\n        if len(x.shape) not in {1, 2}:\n            raise ValueError(\n                f\"Only supports 1D or 2D inputs, provided {len(x.shape)}D.\"\n            )\n\n        batch_size = x.shape[0] if len(x.shape) == 2 else None\n        num_samples = x.shape[-1]\n\n        if batch_size is None:\n            x = tf.reshape(x, (1, -1))  # Convert to batch format\n\n        num_segments = compute_num_segments(\n            num_samples, self.window.hop_size, self.window.analysis_window.shape[-1]\n        )\n\n        if num_segments &lt;= 0:\n            raise ValueError(\n                \"Input signal is too short for segmentation with the given parameters.\"\n            )\n\n        # Pre-allocation\n        X = tf.zeros(\n            (\n                batch_size if batch_size is not None else 1,\n                num_segments,\n                self.window.analysis_window.shape[-1],\n            ),\n            dtype=x.dtype,\n        )\n\n        # Windowing\n        analysis_window = tf.convert_to_tensor(\n            self.window.analysis_window, dtype=x.dtype\n        )\n        for k in range(num_segments):\n            start_idx = k * self.window.hop_size\n            X = tf.tensor_scatter_nd_update(\n                X,\n                [\n                    [i, k, j]\n                    for i in range(batch_size if batch_size is not None else 1)\n                    for j in range(self.window.analysis_window.shape[-1])\n                ],\n                tf.reshape(\n                    x[:, start_idx : start_idx + self.window.analysis_window.shape[-1]]\n                    * analysis_window,\n                    [-1],\n                ),\n            )\n\n        return tf.squeeze(X, axis=0) if batch_size is None else X\n\n    def unsegment(self, X: tf.Tensor) -&gt; tf.Tensor:\n        \"\"\"\n        Reconstructs the original signal from segmented data.\n\n        Args:\n            X (tf.Tensor): Segmented tensor (2D or 3D).\n\n        Returns:\n            Reconstructed 1D or 2D signal.\n\n        \"\"\"\n        if self.window.synthesis_window is None:\n            raise ValueError(\"Given windowing scheme does not support unsegmenting.\")\n\n        if len(X.shape) not in {2, 3}:\n            raise ValueError(\n                f\"Only supports 2D or 3D inputs, provided {len(X.shape)}D.\"\n            )\n\n        batch_size = X.shape[0] if len(X.shape) == 3 else None\n        num_segments = X.shape[-2]\n        segment_size = X.shape[-1]\n\n        if batch_size is None:\n            X = tf.reshape(X, (1, num_segments, -1))  # Convert to batch format\n\n        num_samples = compute_num_samples(\n            num_segments, self.window.hop_size, segment_size\n        )\n\n        if num_samples &lt;= 0:\n            raise ValueError(\n                \"Invalid segment structure, possibly due to incorrect windowing \"\n                + \"parameters.\"\n            )\n\n        # Allocate memory for the reconstructed signal\n        x = tf.zeros(\n            (batch_size if batch_size is not None else 1, num_samples), dtype=X.dtype\n        )\n\n        # Overlap-add method for reconstructing the original signal\n        tf.convert_to_tensor(self.window.synthesis_window, dtype=X.dtype)\n\n        for k in range(num_segments):\n            tmpIdx = tf.reshape(\n                tf.range(\n                    k * self.window.hop_size, k * self.window.hop_size + segment_size\n                ),\n                shape=(segment_size, 1),\n            )\n\n            for b in range(batch_size if batch_size is not None else 1):\n                idx = tf.concat([tf.fill((segment_size, 1), b), tmpIdx], axis=1)\n                x = tf.tensor_scatter_nd_add(\n                    x, idx, self.window.synthesis_window * X[b, k, :]\n                )\n\n        return tf.squeeze(x, axis=0) if batch_size is None else x\n</code></pre>"},{"location":"api/backends/SegmenterTensorFlow/#libsegmenter.backends.SegmenterTensorFlow.SegmenterTensorFlow.__init__","title":"<code>__init__(window)</code>","text":"<p>Initializes the SegmenterTensorFlow instance.</p> <p>Parameters:</p> Name Type Description Default <code>window</code> <code>Window</code> <p>A window object containing segmentation parameters.</p> required Source code in <code>src/libsegmenter/backends/SegmenterTensorFlow.py</code> <pre><code>def __init__(self, window: Window) -&gt; None:\n    \"\"\"\n    Initializes the SegmenterTensorFlow instance.\n\n    Args:\n        window (Window): A window object containing segmentation parameters.\n\n    \"\"\"\n    super(SegmenterTensorFlow, self).__init__()  # type: ignore\n\n    self.window = window\n</code></pre>"},{"location":"api/backends/SegmenterTensorFlow/#libsegmenter.backends.SegmenterTensorFlow.SegmenterTensorFlow.segment","title":"<code>segment(x)</code>","text":"<p>Segments the input tensor into overlapping windows.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>Input tensor (1D or 2D).</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Segmented tensor of shape (batch_size, num_segments, segment_size).</p> Source code in <code>src/libsegmenter/backends/SegmenterTensorFlow.py</code> <pre><code>def segment(self, x: tf.Tensor) -&gt; tf.Tensor:\n    \"\"\"\n    Segments the input tensor into overlapping windows.\n\n    Args:\n        x (tf.Tensor): Input tensor (1D or 2D).\n\n    Returns:\n        Segmented tensor of shape (batch_size, num_segments, segment_size).\n\n    \"\"\"\n    if len(x.shape) not in {1, 2}:\n        raise ValueError(\n            f\"Only supports 1D or 2D inputs, provided {len(x.shape)}D.\"\n        )\n\n    batch_size = x.shape[0] if len(x.shape) == 2 else None\n    num_samples = x.shape[-1]\n\n    if batch_size is None:\n        x = tf.reshape(x, (1, -1))  # Convert to batch format\n\n    num_segments = compute_num_segments(\n        num_samples, self.window.hop_size, self.window.analysis_window.shape[-1]\n    )\n\n    if num_segments &lt;= 0:\n        raise ValueError(\n            \"Input signal is too short for segmentation with the given parameters.\"\n        )\n\n    # Pre-allocation\n    X = tf.zeros(\n        (\n            batch_size if batch_size is not None else 1,\n            num_segments,\n            self.window.analysis_window.shape[-1],\n        ),\n        dtype=x.dtype,\n    )\n\n    # Windowing\n    analysis_window = tf.convert_to_tensor(\n        self.window.analysis_window, dtype=x.dtype\n    )\n    for k in range(num_segments):\n        start_idx = k * self.window.hop_size\n        X = tf.tensor_scatter_nd_update(\n            X,\n            [\n                [i, k, j]\n                for i in range(batch_size if batch_size is not None else 1)\n                for j in range(self.window.analysis_window.shape[-1])\n            ],\n            tf.reshape(\n                x[:, start_idx : start_idx + self.window.analysis_window.shape[-1]]\n                * analysis_window,\n                [-1],\n            ),\n        )\n\n    return tf.squeeze(X, axis=0) if batch_size is None else X\n</code></pre>"},{"location":"api/backends/SegmenterTensorFlow/#libsegmenter.backends.SegmenterTensorFlow.SegmenterTensorFlow.unsegment","title":"<code>unsegment(X)</code>","text":"<p>Reconstructs the original signal from segmented data.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>Tensor</code> <p>Segmented tensor (2D or 3D).</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Reconstructed 1D or 2D signal.</p> Source code in <code>src/libsegmenter/backends/SegmenterTensorFlow.py</code> <pre><code>def unsegment(self, X: tf.Tensor) -&gt; tf.Tensor:\n    \"\"\"\n    Reconstructs the original signal from segmented data.\n\n    Args:\n        X (tf.Tensor): Segmented tensor (2D or 3D).\n\n    Returns:\n        Reconstructed 1D or 2D signal.\n\n    \"\"\"\n    if self.window.synthesis_window is None:\n        raise ValueError(\"Given windowing scheme does not support unsegmenting.\")\n\n    if len(X.shape) not in {2, 3}:\n        raise ValueError(\n            f\"Only supports 2D or 3D inputs, provided {len(X.shape)}D.\"\n        )\n\n    batch_size = X.shape[0] if len(X.shape) == 3 else None\n    num_segments = X.shape[-2]\n    segment_size = X.shape[-1]\n\n    if batch_size is None:\n        X = tf.reshape(X, (1, num_segments, -1))  # Convert to batch format\n\n    num_samples = compute_num_samples(\n        num_segments, self.window.hop_size, segment_size\n    )\n\n    if num_samples &lt;= 0:\n        raise ValueError(\n            \"Invalid segment structure, possibly due to incorrect windowing \"\n            + \"parameters.\"\n        )\n\n    # Allocate memory for the reconstructed signal\n    x = tf.zeros(\n        (batch_size if batch_size is not None else 1, num_samples), dtype=X.dtype\n    )\n\n    # Overlap-add method for reconstructing the original signal\n    tf.convert_to_tensor(self.window.synthesis_window, dtype=X.dtype)\n\n    for k in range(num_segments):\n        tmpIdx = tf.reshape(\n            tf.range(\n                k * self.window.hop_size, k * self.window.hop_size + segment_size\n            ),\n            shape=(segment_size, 1),\n        )\n\n        for b in range(batch_size if batch_size is not None else 1):\n            idx = tf.concat([tf.fill((segment_size, 1), b), tmpIdx], axis=1)\n            x = tf.tensor_scatter_nd_add(\n                x, idx, self.window.synthesis_window * X[b, k, :]\n            )\n\n    return tf.squeeze(x, axis=0) if batch_size is None else x\n</code></pre>"},{"location":"api/backends/SegmenterTorch/","title":"SegmenterTorch","text":""},{"location":"api/backends/SegmenterTorch/#libsegmenter.backends.SegmenterTorch.SegmenterTorch","title":"<code>SegmenterTorch</code>","text":"<p>               Bases: <code>Module</code></p> <p>A PyTorch-based segmenter for input data using windowing techniques.</p> <p>Supports Weighted Overlap-Add (WOLA) and Overlap-Add (OLA) methods.</p> <p>Attributes:</p> Name Type Description <code>window</code> <code>Window</code> <p>A class containing hop size and windows.</p> Source code in <code>src/libsegmenter/backends/SegmenterTorch.py</code> <pre><code>class SegmenterTorch(torch.nn.Module):\n    \"\"\"\n    A PyTorch-based segmenter for input data using windowing techniques.\n\n    Supports Weighted Overlap-Add (WOLA) and Overlap-Add (OLA) methods.\n\n    Attributes:\n        window (Window): A class containing hop size and windows.\n\n    \"\"\"\n\n    def __init__(self, window: Window) -&gt; None:\n        \"\"\"\n        Initializes the SegmenterTorch instance.\n\n        Args:\n            window (Window): A window object containing segmentation parameters.\n\n        \"\"\"\n        super().__init__()  # type: ignore\n\n        self.window = window\n\n    def segment(self, x: torch.Tensor) -&gt; torch.Tensor:\n        \"\"\"\n        Segments the input tensor into overlapping windows.\n\n        Args:\n            x (torch.Tensor): Input tensor (1D or 2D).\n\n        Returns:\n            Segmented tensor of shape (batch_size, num_segments, segment_size).\n\n        Raises:\n            ValueError: If types are incorrect.\n            ValueError: If input dimensions are invalid.\n\n        \"\"\"\n        if x.ndim not in {1, 2}:\n            raise ValueError(f\"Only supports 1D or 2D inputs, provided {x.ndim}D.\")\n\n        batch_size = x.shape[0] if x.ndim == 2 else None\n        num_samples = x.shape[-1]\n\n        if batch_size is None:\n            x = x.reshape(1, -1)  # Convert to batch format for consistency\n\n        num_segments = compute_num_segments(\n            num_samples, self.window.hop_size, self.window.analysis_window.shape[-1]\n        )\n\n        if num_segments &lt;= 0:\n            raise ValueError(\n                \"Input signal is too short for segmentation with the given parameters.\"\n            )\n\n        # Windowing\n        analysis_window = torch.tensor(\n            self.window.analysis_window, device=x.device, dtype=x.dtype\n        )\n\n        idxs = torch.arange(num_segments, device=x.device) * self.window.hop_size\n        frame_idxs = idxs.unsqueeze(1) + torch.arange(\n            self.window.analysis_window.shape[-1], device=x.device\n        )\n        y = x[:, frame_idxs] * analysis_window\n\n        return (\n            y.squeeze(0) if batch_size is None else y\n        )  # Remove batch dimension if needed\n\n    def unsegment(self, y: torch.Tensor) -&gt; torch.Tensor:\n        \"\"\"\n        Reconstructs the original signal from segmented data.\n\n        Args:\n            y (torch.Tensor): Segmented tensor (2D or 3D).\n\n        Returns:\n            Reconstructed 1D or 2D signal.\n\n        Raises:\n            ValueError: If types are incorrect.\n            ValueError: If input dimensions are invalid.\n\n        \"\"\"\n        if self.window.synthesis_window is None:\n            raise ValueError(\"Given windowing scheme does not support unsegmenting.\")\n\n        if y.ndim not in {2, 3}:\n            raise ValueError(f\"Only supports 2D or 3D inputs, provided {y.ndim}D.\")\n\n        batch_size = y.shape[0] if y.ndim == 3 else None\n        num_segments = y.shape[-2]\n        segment_size = y.shape[-1]\n\n        if batch_size is None:\n            y = y.reshape(1, num_segments, -1)  # Convert to batch format\n\n        num_samples = compute_num_samples(\n            num_segments, self.window.hop_size, segment_size\n        )\n\n        if num_samples &lt;= 0:\n            raise ValueError(\n                \"Invalid segment structure, possibly due to incorrect windowing \"\n                + \"parameters.\"\n            )\n\n        # allocate memory for the reconstructed signal\n        x = torch.zeros(\n            (batch_size if batch_size is not None else 1, num_samples),\n            device=y.device,\n            dtype=y.dtype,\n        )\n\n        # overlap-add method for reconstructing the original signal\n        synthesis_window = torch.tensor(\n            self.window.synthesis_window, device=y.device, dtype=y.dtype\n        )\n\n        frame_idxs = (\n            torch.arange(num_segments, device=y.device) * self.window.hop_size\n        ).unsqueeze(1) + torch.arange(segment_size, device=y.device)\n        frame_idxs = frame_idxs.flatten()\n        x.scatter_add_(\n            1,\n            frame_idxs.unsqueeze(0).expand(x.shape[0], -1),\n            (y * synthesis_window).reshape(x.shape[0], -1),\n        )\n\n        return x.squeeze(0) if batch_size is None else x\n</code></pre>"},{"location":"api/backends/SegmenterTorch/#libsegmenter.backends.SegmenterTorch.SegmenterTorch.__init__","title":"<code>__init__(window)</code>","text":"<p>Initializes the SegmenterTorch instance.</p> <p>Parameters:</p> Name Type Description Default <code>window</code> <code>Window</code> <p>A window object containing segmentation parameters.</p> required Source code in <code>src/libsegmenter/backends/SegmenterTorch.py</code> <pre><code>def __init__(self, window: Window) -&gt; None:\n    \"\"\"\n    Initializes the SegmenterTorch instance.\n\n    Args:\n        window (Window): A window object containing segmentation parameters.\n\n    \"\"\"\n    super().__init__()  # type: ignore\n\n    self.window = window\n</code></pre>"},{"location":"api/backends/SegmenterTorch/#libsegmenter.backends.SegmenterTorch.SegmenterTorch.segment","title":"<code>segment(x)</code>","text":"<p>Segments the input tensor into overlapping windows.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>Input tensor (1D or 2D).</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Segmented tensor of shape (batch_size, num_segments, segment_size).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If types are incorrect.</p> <code>ValueError</code> <p>If input dimensions are invalid.</p> Source code in <code>src/libsegmenter/backends/SegmenterTorch.py</code> <pre><code>def segment(self, x: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"\n    Segments the input tensor into overlapping windows.\n\n    Args:\n        x (torch.Tensor): Input tensor (1D or 2D).\n\n    Returns:\n        Segmented tensor of shape (batch_size, num_segments, segment_size).\n\n    Raises:\n        ValueError: If types are incorrect.\n        ValueError: If input dimensions are invalid.\n\n    \"\"\"\n    if x.ndim not in {1, 2}:\n        raise ValueError(f\"Only supports 1D or 2D inputs, provided {x.ndim}D.\")\n\n    batch_size = x.shape[0] if x.ndim == 2 else None\n    num_samples = x.shape[-1]\n\n    if batch_size is None:\n        x = x.reshape(1, -1)  # Convert to batch format for consistency\n\n    num_segments = compute_num_segments(\n        num_samples, self.window.hop_size, self.window.analysis_window.shape[-1]\n    )\n\n    if num_segments &lt;= 0:\n        raise ValueError(\n            \"Input signal is too short for segmentation with the given parameters.\"\n        )\n\n    # Windowing\n    analysis_window = torch.tensor(\n        self.window.analysis_window, device=x.device, dtype=x.dtype\n    )\n\n    idxs = torch.arange(num_segments, device=x.device) * self.window.hop_size\n    frame_idxs = idxs.unsqueeze(1) + torch.arange(\n        self.window.analysis_window.shape[-1], device=x.device\n    )\n    y = x[:, frame_idxs] * analysis_window\n\n    return (\n        y.squeeze(0) if batch_size is None else y\n    )  # Remove batch dimension if needed\n</code></pre>"},{"location":"api/backends/SegmenterTorch/#libsegmenter.backends.SegmenterTorch.SegmenterTorch.unsegment","title":"<code>unsegment(y)</code>","text":"<p>Reconstructs the original signal from segmented data.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>Tensor</code> <p>Segmented tensor (2D or 3D).</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Reconstructed 1D or 2D signal.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If types are incorrect.</p> <code>ValueError</code> <p>If input dimensions are invalid.</p> Source code in <code>src/libsegmenter/backends/SegmenterTorch.py</code> <pre><code>def unsegment(self, y: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"\n    Reconstructs the original signal from segmented data.\n\n    Args:\n        y (torch.Tensor): Segmented tensor (2D or 3D).\n\n    Returns:\n        Reconstructed 1D or 2D signal.\n\n    Raises:\n        ValueError: If types are incorrect.\n        ValueError: If input dimensions are invalid.\n\n    \"\"\"\n    if self.window.synthesis_window is None:\n        raise ValueError(\"Given windowing scheme does not support unsegmenting.\")\n\n    if y.ndim not in {2, 3}:\n        raise ValueError(f\"Only supports 2D or 3D inputs, provided {y.ndim}D.\")\n\n    batch_size = y.shape[0] if y.ndim == 3 else None\n    num_segments = y.shape[-2]\n    segment_size = y.shape[-1]\n\n    if batch_size is None:\n        y = y.reshape(1, num_segments, -1)  # Convert to batch format\n\n    num_samples = compute_num_samples(\n        num_segments, self.window.hop_size, segment_size\n    )\n\n    if num_samples &lt;= 0:\n        raise ValueError(\n            \"Invalid segment structure, possibly due to incorrect windowing \"\n            + \"parameters.\"\n        )\n\n    # allocate memory for the reconstructed signal\n    x = torch.zeros(\n        (batch_size if batch_size is not None else 1, num_samples),\n        device=y.device,\n        dtype=y.dtype,\n    )\n\n    # overlap-add method for reconstructing the original signal\n    synthesis_window = torch.tensor(\n        self.window.synthesis_window, device=y.device, dtype=y.dtype\n    )\n\n    frame_idxs = (\n        torch.arange(num_segments, device=y.device) * self.window.hop_size\n    ).unsqueeze(1) + torch.arange(segment_size, device=y.device)\n    frame_idxs = frame_idxs.flatten()\n    x.scatter_add_(\n        1,\n        frame_idxs.unsqueeze(0).expand(x.shape[0], -1),\n        (y * synthesis_window).reshape(x.shape[0], -1),\n    )\n\n    return x.squeeze(0) if batch_size is None else x\n</code></pre>"},{"location":"api/transforms/BPD/","title":"BPD","text":""},{"location":"api/transforms/BPD/#libsegmenter.transforms.BPD.BPD","title":"<code>BPD(backend='numpy', *args, **kwargs)</code>","text":"<p>Factory function to create a bpd instance based on the specified backend.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>str</code> <p>The backend to use. Supported options: [\"numpy\", \"torch\", \"tensorflow\"]. Defaults to \"numpy\".</p> <code>'numpy'</code> <code>*args</code> <code>Any</code> <p>Additional positional arguments to pass to the segmenter.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to the segmenter.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>An instance of the transform corresponding to the chosen backend.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unsupported backend is specified.</p> <code>NotImplementedError</code> <p>If the backend is not implemented.</p> Source code in <code>src/libsegmenter/transforms/BPD.py</code> <pre><code>def BPD(backend: str = \"numpy\", *args: Any, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Factory function to create a bpd instance based on the specified backend.\n\n    Args:\n        backend (str, optional): The backend to use. Supported options:\n            [\"numpy\", \"torch\", \"tensorflow\"]. Defaults to \"numpy\".\n        *args (Any): Additional positional arguments to pass to the segmenter.\n        **kwargs (Any): Additional keyword arguments to pass to the segmenter.\n\n    Returns:\n        An instance of the transform corresponding to the chosen backend.\n\n    Raises:\n        ValueError: If an unsupported backend is specified.\n        NotImplementedError: If the backend is not implemented.\n\n    \"\"\"\n    # if backend == \"numpy\":\n    #     from libsegmenter.transforms.bpd.BPDNumpy import BPDNumpy\n    #\n    #     return BPDNumpy(*args, **kwargs)\n\n    _ = args\n    _ = kwargs\n\n    raise ValueError(f\"The '{backend}' transform is not known.\")\n</code></pre>"},{"location":"api/transforms/MagnitudePhase/","title":"Magnitude","text":""},{"location":"api/transforms/MagnitudePhase/#libsegmenter.transforms.MagnitudePhase.MagnitudePhase","title":"<code>MagnitudePhase(backend='numpy', *args, **kwargs)</code>","text":"<p>Factory function to create a magnitude_phase instance based on the backend.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>str</code> <p>The backend to use. Supported options: [\"numpy\", \"torch\", \"tensorflow\"]. Defaults to \"numpy\".</p> <code>'numpy'</code> <code>*args</code> <code>Any</code> <p>Additional positional arguments to pass to the segmenter.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to the segmenter.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>An instance of the transform corresponding to the chosen backend.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unsupported backend is specified.</p> <code>NotImplementedError</code> <p>If the backend is not implemented.</p> Source code in <code>src/libsegmenter/transforms/MagnitudePhase.py</code> <pre><code>def MagnitudePhase(backend: str = \"numpy\", *args: Any, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Factory function to create a magnitude_phase instance based on the backend.\n\n    Args:\n        backend (str, optional): The backend to use. Supported options:\n            [\"numpy\", \"torch\", \"tensorflow\"]. Defaults to \"numpy\".\n        *args (Any): Additional positional arguments to pass to the segmenter.\n        **kwargs (Any): Additional keyword arguments to pass to the segmenter.\n\n    Returns:\n        An instance of the transform corresponding to the chosen backend.\n\n    Raises:\n        ValueError: If an unsupported backend is specified.\n        NotImplementedError: If the backend is not implemented.\n\n    \"\"\"\n    if backend == \"numpy\":\n        from libsegmenter.transforms.magnitude_phase.MagnitudePhaseNumpy import (\n            MagnitudePhaseNumpy,\n        )\n\n        return MagnitudePhaseNumpy(*args, **kwargs)\n\n    if backend == \"tensorflow\":\n        from libsegmenter.transforms.magnitude_phase.MagnitudePhaseTensorFlow import (\n            MagnitudePhaseTensorFlow,\n        )\n\n        return MagnitudePhaseTensorFlow(*args, **kwargs)\n\n    if backend == \"torch\":\n        from libsegmenter.transforms.magnitude_phase.MagnitudePhaseTorch import (\n            MagnitudePhaseTorch,\n        )\n\n        return MagnitudePhaseTorch(*args, **kwargs)\n\n    raise ValueError(f\"The '{backend}' backend is not known.\")\n</code></pre>"},{"location":"api/transforms/Spectrogram/","title":"Spectrogram","text":""},{"location":"api/transforms/Spectrogram/#libsegmenter.transforms.Spectrogram.Spectrogram","title":"<code>Spectrogram(backend='numpy', *args, **kwargs)</code>","text":"<p>Factory function to create a spectrogram instance based on the specified backend.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>str</code> <p>The backend to use. Supported options: [\"numpy\", \"torch\", \"tensorflow\"]. Defaults to \"numpy\".</p> <code>'numpy'</code> <code>*args</code> <code>Any</code> <p>Additional positional arguments to pass to the segmenter.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to the segmenter.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>An instance of the transform corresponding to the chosen backend.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unsupported backend is specified.</p> <code>NotImplementedError</code> <p>If the backend is not implemented.</p> Source code in <code>src/libsegmenter/transforms/Spectrogram.py</code> <pre><code>def Spectrogram(backend: str = \"numpy\", *args: Any, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Factory function to create a spectrogram instance based on the specified backend.\n\n    Args:\n        backend (str, optional): The backend to use. Supported options:\n            [\"numpy\", \"torch\", \"tensorflow\"]. Defaults to \"numpy\".\n        *args (Any): Additional positional arguments to pass to the segmenter.\n        **kwargs (Any): Additional keyword arguments to pass to the segmenter.\n\n    Returns:\n        An instance of the transform corresponding to the chosen backend.\n\n    Raises:\n        ValueError: If an unsupported backend is specified.\n        NotImplementedError: If the backend is not implemented.\n\n    \"\"\"\n    if backend == \"numpy\":\n        from libsegmenter.transforms.spectrogram.SpectrogramNumpy import (\n            SpectrogramNumpy,\n        )\n\n        return SpectrogramNumpy(*args, **kwargs)\n\n    if backend == \"tensorflow\":\n        from libsegmenter.transforms.spectrogram.SpectrogramTensorFlow import (\n            SpectrogramTensorFlow,\n        )\n\n        return SpectrogramTensorFlow(*args, **kwargs)\n\n    if backend == \"torch\":\n        from libsegmenter.transforms.spectrogram.SpectrogramTorch import (\n            SpectrogramTorch,\n        )\n\n        return SpectrogramTorch(*args, **kwargs)\n\n    raise ValueError(f\"The '{backend}' backend is not known.\")\n</code></pre>"},{"location":"api/transforms/bpd/BPDNumpy/","title":"BPDNumpy","text":""},{"location":"api/transforms/bpd/BPDNumpy/#libsegmenter.transforms.bpd.BPDNumpy.BPDNumpy","title":"<code>BPDNumpy</code>","text":"<p>A class for computing bpds.</p> <p>Currently, the normalization cannot be controlled and is thus <code>backward</code> by default.</p> Source code in <code>src/libsegmenter/transforms/bpd/BPDNumpy.py</code> <pre><code>class BPDNumpy:\n    \"\"\"\n    A class for computing bpds.\n\n    Currently, the normalization cannot be controlled and is thus `backward` by default.\n\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initializes the BPDNumpy instance.\"\"\"\n        return\n\n    def forward(self, x: NDArray[T]) -&gt; NDArray[np.complex128]:\n        \"\"\"\n        Converts segments into a bpd.\n\n        Args:\n            x (NDArray[T]): Segments as generated by a Segmenter object.\n\n        \"\"\"\n        return np.fft.rfft(x, axis=-1, norm=\"backward\")\n\n    def inverse(self, y: NDArray[np.complex128]) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Converts bpd into segments.\n\n        Args:\n            y (NDArray[np.complex128]): BPD resulting from a `forward` pass.\n\n        \"\"\"\n        return np.fft.irfft(y, axis=-1, norm=\"backward\")\n</code></pre>"},{"location":"api/transforms/bpd/BPDNumpy/#libsegmenter.transforms.bpd.BPDNumpy.BPDNumpy.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the BPDNumpy instance.</p> Source code in <code>src/libsegmenter/transforms/bpd/BPDNumpy.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initializes the BPDNumpy instance.\"\"\"\n    return\n</code></pre>"},{"location":"api/transforms/bpd/BPDNumpy/#libsegmenter.transforms.bpd.BPDNumpy.BPDNumpy.forward","title":"<code>forward(x)</code>","text":"<p>Converts segments into a bpd.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NDArray[T]</code> <p>Segments as generated by a Segmenter object.</p> required Source code in <code>src/libsegmenter/transforms/bpd/BPDNumpy.py</code> <pre><code>def forward(self, x: NDArray[T]) -&gt; NDArray[np.complex128]:\n    \"\"\"\n    Converts segments into a bpd.\n\n    Args:\n        x (NDArray[T]): Segments as generated by a Segmenter object.\n\n    \"\"\"\n    return np.fft.rfft(x, axis=-1, norm=\"backward\")\n</code></pre>"},{"location":"api/transforms/bpd/BPDNumpy/#libsegmenter.transforms.bpd.BPDNumpy.BPDNumpy.inverse","title":"<code>inverse(y)</code>","text":"<p>Converts bpd into segments.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>NDArray[complex128]</code> <p>BPD resulting from a <code>forward</code> pass.</p> required Source code in <code>src/libsegmenter/transforms/bpd/BPDNumpy.py</code> <pre><code>def inverse(self, y: NDArray[np.complex128]) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Converts bpd into segments.\n\n    Args:\n        y (NDArray[np.complex128]): BPD resulting from a `forward` pass.\n\n    \"\"\"\n    return np.fft.irfft(y, axis=-1, norm=\"backward\")\n</code></pre>"},{"location":"api/transforms/bpd/BPDTensorFlow/","title":"BPDTensorFlow","text":""},{"location":"api/transforms/bpd/BPDTorch/","title":"BPDTorch","text":""},{"location":"api/transforms/magnitude_phase/MagnitudePhaseNumpy/","title":"MagnitudePhaseNumpy","text":""},{"location":"api/transforms/magnitude_phase/MagnitudePhaseNumpy/#libsegmenter.transforms.magnitude_phase.MagnitudePhaseNumpy.MagnitudePhaseNumpy","title":"<code>MagnitudePhaseNumpy</code>","text":"<p>A class for computing magnitude and phase spectra.</p> <p>Currently, the normalization for the fourier transform cannot be controlled and is thus <code>backward</code> by default.</p> Source code in <code>src/libsegmenter/transforms/magnitude_phase/MagnitudePhaseNumpy.py</code> <pre><code>class MagnitudePhaseNumpy:\n    \"\"\"\n    A class for computing magnitude and phase spectra.\n\n    Currently, the normalization for the fourier transform cannot be controlled and is\n    thus `backward` by default.\n\n    \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"Initializes the MagnitudePhaseNumpy instance.\"\"\"\n        self._spectrogram = SpectrogramNumpy(*args, **kwargs)\n\n    def forward(self, x: NDArray[T]) -&gt; Tuple[NDArray[Any], NDArray[Any]]:\n        \"\"\"\n        Converts segments into a magnitude and phase spectrogram.\n\n        Args:\n            x (NDArray[T]): Segments as generated by a Segmenter object.\n\n        \"\"\"\n        tensor = self._spectrogram.forward(x)\n        return np.abs(tensor), np.angle(tensor)\n\n    def inverse(\n        self, magnitude: NDArray[np.complex128], phase: NDArray[np.complex128]\n    ) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Converts magnitude / phase spectrogram into segments.\n\n        Args:\n            magnitude (NDArray[np.complex128]): MagnitudePhase spectrogram resulting\n                from a `forward` pass.\n            phase (NDArray[np.complex128]): Phase spectrogram resulting from a\n                `forward` pass.\n\n        \"\"\"\n        return self._spectrogram.inverse(np.multiply(magnitude, np.exp(1j * phase)))\n</code></pre>"},{"location":"api/transforms/magnitude_phase/MagnitudePhaseNumpy/#libsegmenter.transforms.magnitude_phase.MagnitudePhaseNumpy.MagnitudePhaseNumpy.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initializes the MagnitudePhaseNumpy instance.</p> Source code in <code>src/libsegmenter/transforms/magnitude_phase/MagnitudePhaseNumpy.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Initializes the MagnitudePhaseNumpy instance.\"\"\"\n    self._spectrogram = SpectrogramNumpy(*args, **kwargs)\n</code></pre>"},{"location":"api/transforms/magnitude_phase/MagnitudePhaseNumpy/#libsegmenter.transforms.magnitude_phase.MagnitudePhaseNumpy.MagnitudePhaseNumpy.forward","title":"<code>forward(x)</code>","text":"<p>Converts segments into a magnitude and phase spectrogram.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NDArray[T]</code> <p>Segments as generated by a Segmenter object.</p> required Source code in <code>src/libsegmenter/transforms/magnitude_phase/MagnitudePhaseNumpy.py</code> <pre><code>def forward(self, x: NDArray[T]) -&gt; Tuple[NDArray[Any], NDArray[Any]]:\n    \"\"\"\n    Converts segments into a magnitude and phase spectrogram.\n\n    Args:\n        x (NDArray[T]): Segments as generated by a Segmenter object.\n\n    \"\"\"\n    tensor = self._spectrogram.forward(x)\n    return np.abs(tensor), np.angle(tensor)\n</code></pre>"},{"location":"api/transforms/magnitude_phase/MagnitudePhaseNumpy/#libsegmenter.transforms.magnitude_phase.MagnitudePhaseNumpy.MagnitudePhaseNumpy.inverse","title":"<code>inverse(magnitude, phase)</code>","text":"<p>Converts magnitude / phase spectrogram into segments.</p> <p>Parameters:</p> Name Type Description Default <code>magnitude</code> <code>NDArray[complex128]</code> <p>MagnitudePhase spectrogram resulting from a <code>forward</code> pass.</p> required <code>phase</code> <code>NDArray[complex128]</code> <p>Phase spectrogram resulting from a <code>forward</code> pass.</p> required Source code in <code>src/libsegmenter/transforms/magnitude_phase/MagnitudePhaseNumpy.py</code> <pre><code>def inverse(\n    self, magnitude: NDArray[np.complex128], phase: NDArray[np.complex128]\n) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Converts magnitude / phase spectrogram into segments.\n\n    Args:\n        magnitude (NDArray[np.complex128]): MagnitudePhase spectrogram resulting\n            from a `forward` pass.\n        phase (NDArray[np.complex128]): Phase spectrogram resulting from a\n            `forward` pass.\n\n    \"\"\"\n    return self._spectrogram.inverse(np.multiply(magnitude, np.exp(1j * phase)))\n</code></pre>"},{"location":"api/transforms/magnitude_phase/MagnitudePhaseTensorFlow/","title":"MagnitudeTensorFlow","text":""},{"location":"api/transforms/magnitude_phase/MagnitudePhaseTensorFlow/#libsegmenter.transforms.magnitude_phase.MagnitudePhaseTensorFlow.MagnitudePhaseTensorFlow","title":"<code>MagnitudePhaseTensorFlow</code>","text":"<p>A class for computing magnitudes using TensorFlow.</p> Source code in <code>src/libsegmenter/transforms/magnitude_phase/MagnitudePhaseTensorFlow.py</code> <pre><code>class MagnitudePhaseTensorFlow:\n    \"\"\"A class for computing magnitudes using TensorFlow.\"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"Initializes the MagnitudePhaseTensorFlow instance.\"\"\"\n        self._spectrogram = SpectrogramTensorFlow(*args, **kwargs)\n\n    def forward(self, x: tf.Tensor) -&gt; Tuple[tf.Tensor, tf.Tensor]:\n        \"\"\"\n        Converts segments into a magnitude.\n\n        Args:\n            x (tf.Tensor): Segments as generated by a Segmenter object.\n\n        Returns:\n            tf.Tensor: MagnitudePhase representation.\n\n        \"\"\"\n        tensor = self._spectrogram.forward(x)\n        return tf.abs(tensor), tf.math.angle(tensor)  # pyright: ignore\n\n    def inverse(self, magnitude: tf.Tensor, phase: tf.Tensor) -&gt; tf.Tensor:\n        \"\"\"\n        Converts magnitude / phase spectrogram into segments.\n\n        Args:\n            magnitude (Tensor): MagnitudePhase spectrogram resulting from a `forward`\n                pass.\n            phase (Tensor): Phase spectrogram resulting from a `forward` pass.\n\n        \"\"\"\n        magnitude_complex = tf.cast(magnitude, dtype=tf.complex64)  # pyright: ignore\n        phase_complex = tf.cast(phase, dtype=tf.complex64)  # pyright: ignore\n        j = tf.complex(0.0, 1.0)  # pyright: ignore\n        complex_exp = tf.exp(j * phase_complex)  # pyright: ignore\n\n        return self._spectrogram.inverse(\n            magnitude_complex * complex_exp  # pyright: ignore\n        )\n</code></pre>"},{"location":"api/transforms/magnitude_phase/MagnitudePhaseTensorFlow/#libsegmenter.transforms.magnitude_phase.MagnitudePhaseTensorFlow.MagnitudePhaseTensorFlow.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initializes the MagnitudePhaseTensorFlow instance.</p> Source code in <code>src/libsegmenter/transforms/magnitude_phase/MagnitudePhaseTensorFlow.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Initializes the MagnitudePhaseTensorFlow instance.\"\"\"\n    self._spectrogram = SpectrogramTensorFlow(*args, **kwargs)\n</code></pre>"},{"location":"api/transforms/magnitude_phase/MagnitudePhaseTensorFlow/#libsegmenter.transforms.magnitude_phase.MagnitudePhaseTensorFlow.MagnitudePhaseTensorFlow.forward","title":"<code>forward(x)</code>","text":"<p>Converts segments into a magnitude.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>Segments as generated by a Segmenter object.</p> required <p>Returns:</p> Type Description <code>Tuple[Tensor, Tensor]</code> <p>tf.Tensor: MagnitudePhase representation.</p> Source code in <code>src/libsegmenter/transforms/magnitude_phase/MagnitudePhaseTensorFlow.py</code> <pre><code>def forward(self, x: tf.Tensor) -&gt; Tuple[tf.Tensor, tf.Tensor]:\n    \"\"\"\n    Converts segments into a magnitude.\n\n    Args:\n        x (tf.Tensor): Segments as generated by a Segmenter object.\n\n    Returns:\n        tf.Tensor: MagnitudePhase representation.\n\n    \"\"\"\n    tensor = self._spectrogram.forward(x)\n    return tf.abs(tensor), tf.math.angle(tensor)  # pyright: ignore\n</code></pre>"},{"location":"api/transforms/magnitude_phase/MagnitudePhaseTensorFlow/#libsegmenter.transforms.magnitude_phase.MagnitudePhaseTensorFlow.MagnitudePhaseTensorFlow.inverse","title":"<code>inverse(magnitude, phase)</code>","text":"<p>Converts magnitude / phase spectrogram into segments.</p> <p>Parameters:</p> Name Type Description Default <code>magnitude</code> <code>Tensor</code> <p>MagnitudePhase spectrogram resulting from a <code>forward</code> pass.</p> required <code>phase</code> <code>Tensor</code> <p>Phase spectrogram resulting from a <code>forward</code> pass.</p> required Source code in <code>src/libsegmenter/transforms/magnitude_phase/MagnitudePhaseTensorFlow.py</code> <pre><code>def inverse(self, magnitude: tf.Tensor, phase: tf.Tensor) -&gt; tf.Tensor:\n    \"\"\"\n    Converts magnitude / phase spectrogram into segments.\n\n    Args:\n        magnitude (Tensor): MagnitudePhase spectrogram resulting from a `forward`\n            pass.\n        phase (Tensor): Phase spectrogram resulting from a `forward` pass.\n\n    \"\"\"\n    magnitude_complex = tf.cast(magnitude, dtype=tf.complex64)  # pyright: ignore\n    phase_complex = tf.cast(phase, dtype=tf.complex64)  # pyright: ignore\n    j = tf.complex(0.0, 1.0)  # pyright: ignore\n    complex_exp = tf.exp(j * phase_complex)  # pyright: ignore\n\n    return self._spectrogram.inverse(\n        magnitude_complex * complex_exp  # pyright: ignore\n    )\n</code></pre>"},{"location":"api/transforms/magnitude_phase/MagnitudePhaseTorch/","title":"MagnitudeTorch","text":""},{"location":"api/transforms/magnitude_phase/MagnitudePhaseTorch/#libsegmenter.transforms.magnitude_phase.MagnitudePhaseTorch.MagnitudePhaseTorch","title":"<code>MagnitudePhaseTorch</code>","text":"<p>A class for computing magnitudes using PyTorch.</p> Source code in <code>src/libsegmenter/transforms/magnitude_phase/MagnitudePhaseTorch.py</code> <pre><code>class MagnitudePhaseTorch:\n    \"\"\"A class for computing magnitudes using PyTorch.\"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"Initializes the MagnitudePhaseTorch instance.\"\"\"\n        self._spectrogram = SpectrogramTorch(*args, **kwargs)\n\n    def forward(self, x: torch.Tensor) -&gt; Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Converts segments into a magnitude.\n\n        Args:\n            x (Tensor): Segments as generated by a Segmenter object.\n\n        Returns:\n            Tensor: MagnitudePhase representation.\n\n        \"\"\"\n        tensor = self._spectrogram.forward(x)\n        return torch.abs(tensor), torch.angle(tensor)\n\n    def inverse(self, magnitude: torch.Tensor, phase: torch.Tensor) -&gt; torch.Tensor:\n        \"\"\"\n        Converts magnitude / phase spectrogram into segments.\n\n        Args:\n            magnitude (Tensor): MagnitudePhase spectrogram resulting from a `forward`\n                pass.\n            phase (Tensor): Phase spectrogram resulting from a `forward` pass.\n\n        \"\"\"\n        return self._spectrogram.inverse(\n            torch.multiply(magnitude, torch.exp(1j * phase))\n        )\n</code></pre>"},{"location":"api/transforms/magnitude_phase/MagnitudePhaseTorch/#libsegmenter.transforms.magnitude_phase.MagnitudePhaseTorch.MagnitudePhaseTorch.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initializes the MagnitudePhaseTorch instance.</p> Source code in <code>src/libsegmenter/transforms/magnitude_phase/MagnitudePhaseTorch.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Initializes the MagnitudePhaseTorch instance.\"\"\"\n    self._spectrogram = SpectrogramTorch(*args, **kwargs)\n</code></pre>"},{"location":"api/transforms/magnitude_phase/MagnitudePhaseTorch/#libsegmenter.transforms.magnitude_phase.MagnitudePhaseTorch.MagnitudePhaseTorch.forward","title":"<code>forward(x)</code>","text":"<p>Converts segments into a magnitude.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>Segments as generated by a Segmenter object.</p> required <p>Returns:</p> Name Type Description <code>Tensor</code> <code>Tuple[Tensor, Tensor]</code> <p>MagnitudePhase representation.</p> Source code in <code>src/libsegmenter/transforms/magnitude_phase/MagnitudePhaseTorch.py</code> <pre><code>def forward(self, x: torch.Tensor) -&gt; Tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Converts segments into a magnitude.\n\n    Args:\n        x (Tensor): Segments as generated by a Segmenter object.\n\n    Returns:\n        Tensor: MagnitudePhase representation.\n\n    \"\"\"\n    tensor = self._spectrogram.forward(x)\n    return torch.abs(tensor), torch.angle(tensor)\n</code></pre>"},{"location":"api/transforms/magnitude_phase/MagnitudePhaseTorch/#libsegmenter.transforms.magnitude_phase.MagnitudePhaseTorch.MagnitudePhaseTorch.inverse","title":"<code>inverse(magnitude, phase)</code>","text":"<p>Converts magnitude / phase spectrogram into segments.</p> <p>Parameters:</p> Name Type Description Default <code>magnitude</code> <code>Tensor</code> <p>MagnitudePhase spectrogram resulting from a <code>forward</code> pass.</p> required <code>phase</code> <code>Tensor</code> <p>Phase spectrogram resulting from a <code>forward</code> pass.</p> required Source code in <code>src/libsegmenter/transforms/magnitude_phase/MagnitudePhaseTorch.py</code> <pre><code>def inverse(self, magnitude: torch.Tensor, phase: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"\n    Converts magnitude / phase spectrogram into segments.\n\n    Args:\n        magnitude (Tensor): MagnitudePhase spectrogram resulting from a `forward`\n            pass.\n        phase (Tensor): Phase spectrogram resulting from a `forward` pass.\n\n    \"\"\"\n    return self._spectrogram.inverse(\n        torch.multiply(magnitude, torch.exp(1j * phase))\n    )\n</code></pre>"},{"location":"api/transforms/spectrogram/SpectrogramNumpy/","title":"SpectrogramNumpy","text":""},{"location":"api/transforms/spectrogram/SpectrogramNumpy/#libsegmenter.transforms.spectrogram.SpectrogramNumpy.SpectrogramNumpy","title":"<code>SpectrogramNumpy</code>","text":"<p>A class for computing spectrograms.</p> <p>Currently, the normalization for the fourier transform cannot be controlled and is thus <code>backward</code> by default.</p> Source code in <code>src/libsegmenter/transforms/spectrogram/SpectrogramNumpy.py</code> <pre><code>class SpectrogramNumpy:\n    \"\"\"\n    A class for computing spectrograms.\n\n    Currently, the normalization for the fourier transform cannot be controlled and is\n    thus `backward` by default.\n\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initializes the SpectrogramNumpy instance.\"\"\"\n        return\n\n    def forward(self, x: NDArray[T]) -&gt; NDArray[np.complex128]:\n        \"\"\"\n        Converts segments into a spectrogram.\n\n        Args:\n            x (NDArray[T]): Segments as generated by a Segmenter object.\n\n        \"\"\"\n        if x.shape[-1] % 2 != 0:\n            raise ValueError(\n                \"Input segment size is expected to be even for a consistent definition \"\n                + \"of the inverse real-valued FFT.\"\n            )\n        return np.fft.rfft(x, axis=-1, norm=\"backward\")\n\n    def inverse(self, y: NDArray[np.complex128]) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Converts spectrogram into segments.\n\n        Args:\n            y (NDArray[np.complex128]): Spectrogram resulting from a `forward` pass.\n\n        \"\"\"\n        return np.fft.irfft(y, axis=-1, norm=\"backward\")\n</code></pre>"},{"location":"api/transforms/spectrogram/SpectrogramNumpy/#libsegmenter.transforms.spectrogram.SpectrogramNumpy.SpectrogramNumpy.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the SpectrogramNumpy instance.</p> Source code in <code>src/libsegmenter/transforms/spectrogram/SpectrogramNumpy.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initializes the SpectrogramNumpy instance.\"\"\"\n    return\n</code></pre>"},{"location":"api/transforms/spectrogram/SpectrogramNumpy/#libsegmenter.transforms.spectrogram.SpectrogramNumpy.SpectrogramNumpy.forward","title":"<code>forward(x)</code>","text":"<p>Converts segments into a spectrogram.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NDArray[T]</code> <p>Segments as generated by a Segmenter object.</p> required Source code in <code>src/libsegmenter/transforms/spectrogram/SpectrogramNumpy.py</code> <pre><code>def forward(self, x: NDArray[T]) -&gt; NDArray[np.complex128]:\n    \"\"\"\n    Converts segments into a spectrogram.\n\n    Args:\n        x (NDArray[T]): Segments as generated by a Segmenter object.\n\n    \"\"\"\n    if x.shape[-1] % 2 != 0:\n        raise ValueError(\n            \"Input segment size is expected to be even for a consistent definition \"\n            + \"of the inverse real-valued FFT.\"\n        )\n    return np.fft.rfft(x, axis=-1, norm=\"backward\")\n</code></pre>"},{"location":"api/transforms/spectrogram/SpectrogramNumpy/#libsegmenter.transforms.spectrogram.SpectrogramNumpy.SpectrogramNumpy.inverse","title":"<code>inverse(y)</code>","text":"<p>Converts spectrogram into segments.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>NDArray[complex128]</code> <p>Spectrogram resulting from a <code>forward</code> pass.</p> required Source code in <code>src/libsegmenter/transforms/spectrogram/SpectrogramNumpy.py</code> <pre><code>def inverse(self, y: NDArray[np.complex128]) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Converts spectrogram into segments.\n\n    Args:\n        y (NDArray[np.complex128]): Spectrogram resulting from a `forward` pass.\n\n    \"\"\"\n    return np.fft.irfft(y, axis=-1, norm=\"backward\")\n</code></pre>"},{"location":"api/transforms/spectrogram/SpectrogramTensorFlow/","title":"SpectrogramTensorFlow","text":""},{"location":"api/transforms/spectrogram/SpectrogramTensorFlow/#libsegmenter.transforms.spectrogram.SpectrogramTensorFlow.SpectrogramTensorFlow","title":"<code>SpectrogramTensorFlow</code>","text":"<p>A class for computing spectrograms using TensorFlow.</p> <p>The normalization for the Fourier transform is <code>backward</code> by default.</p> Source code in <code>src/libsegmenter/transforms/spectrogram/SpectrogramTensorFlow.py</code> <pre><code>class SpectrogramTensorFlow:\n    \"\"\"\n    A class for computing spectrograms using TensorFlow.\n\n    The normalization for the Fourier transform is `backward` by default.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initializes the SpectrogramTensorFlow instance.\"\"\"\n        return\n\n    def forward(self, x: tf.Tensor) -&gt; tf.Tensor:\n        \"\"\"\n        Converts segments into a spectrogram.\n\n        Args:\n            x (tf.Tensor): Input segments.\n\n        Returns:\n            tf.Tensor: Spectrogram representation.\n\n        \"\"\"\n        s = tf.shape(x).numpy()  # pyright: ignore\n        if s[-1] % 2 != 0:  # pyright: ignore\n            raise ValueError(\n                \"Input segment size is expected to be even for a consistent definition \"\n                + \"of the inverse real-valued FFT.\"\n            )\n        return tf.signal.rfft(x)  # pyright: ignore\n\n    def inverse(self, y: tf.Tensor) -&gt; tf.Tensor:\n        \"\"\"\n        Converts spectrogram into segments.\n\n        Args:\n            y (tf.Tensor): Spectrogram from a `forward` pass.\n\n        Returns:\n            tf.Tensor: Reconstructed segments.\n\n        \"\"\"\n        return tf.signal.irfft(y)  # pyright: ignore\n</code></pre>"},{"location":"api/transforms/spectrogram/SpectrogramTensorFlow/#libsegmenter.transforms.spectrogram.SpectrogramTensorFlow.SpectrogramTensorFlow.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the SpectrogramTensorFlow instance.</p> Source code in <code>src/libsegmenter/transforms/spectrogram/SpectrogramTensorFlow.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initializes the SpectrogramTensorFlow instance.\"\"\"\n    return\n</code></pre>"},{"location":"api/transforms/spectrogram/SpectrogramTensorFlow/#libsegmenter.transforms.spectrogram.SpectrogramTensorFlow.SpectrogramTensorFlow.forward","title":"<code>forward(x)</code>","text":"<p>Converts segments into a spectrogram.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>Input segments.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>tf.Tensor: Spectrogram representation.</p> Source code in <code>src/libsegmenter/transforms/spectrogram/SpectrogramTensorFlow.py</code> <pre><code>def forward(self, x: tf.Tensor) -&gt; tf.Tensor:\n    \"\"\"\n    Converts segments into a spectrogram.\n\n    Args:\n        x (tf.Tensor): Input segments.\n\n    Returns:\n        tf.Tensor: Spectrogram representation.\n\n    \"\"\"\n    s = tf.shape(x).numpy()  # pyright: ignore\n    if s[-1] % 2 != 0:  # pyright: ignore\n        raise ValueError(\n            \"Input segment size is expected to be even for a consistent definition \"\n            + \"of the inverse real-valued FFT.\"\n        )\n    return tf.signal.rfft(x)  # pyright: ignore\n</code></pre>"},{"location":"api/transforms/spectrogram/SpectrogramTensorFlow/#libsegmenter.transforms.spectrogram.SpectrogramTensorFlow.SpectrogramTensorFlow.inverse","title":"<code>inverse(y)</code>","text":"<p>Converts spectrogram into segments.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>Tensor</code> <p>Spectrogram from a <code>forward</code> pass.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>tf.Tensor: Reconstructed segments.</p> Source code in <code>src/libsegmenter/transforms/spectrogram/SpectrogramTensorFlow.py</code> <pre><code>def inverse(self, y: tf.Tensor) -&gt; tf.Tensor:\n    \"\"\"\n    Converts spectrogram into segments.\n\n    Args:\n        y (tf.Tensor): Spectrogram from a `forward` pass.\n\n    Returns:\n        tf.Tensor: Reconstructed segments.\n\n    \"\"\"\n    return tf.signal.irfft(y)  # pyright: ignore\n</code></pre>"},{"location":"api/transforms/spectrogram/SpectrogramTorch/","title":"SpectrogramTorch","text":""},{"location":"api/transforms/spectrogram/SpectrogramTorch/#libsegmenter.transforms.spectrogram.SpectrogramTorch.SpectrogramTorch","title":"<code>SpectrogramTorch</code>","text":"<p>A class for computing spectrograms using PyTorch.</p> <p>The normalization for the Fourier transform is <code>backward</code> by default.</p> Source code in <code>src/libsegmenter/transforms/spectrogram/SpectrogramTorch.py</code> <pre><code>class SpectrogramTorch:\n    \"\"\"\n    A class for computing spectrograms using PyTorch.\n\n    The normalization for the Fourier transform is `backward` by default.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initializes the SpectrogramTorch instance.\"\"\"\n        return\n\n    def forward(self, x: torch.Tensor) -&gt; torch.Tensor:\n        \"\"\"\n        Converts segments into a spectrogram.\n\n        Args:\n            x (torch.Tensor): Input segments.\n\n        Returns:\n            torch.Tensor: Spectrogram representation.\n\n        \"\"\"\n        if x.shape[-1] % 2 != 0:\n            raise ValueError(\n                \"Input segment size is expected to be even for a consistent definition \"\n                + \"of the inverse real-valued FFT.\"\n            )\n        return torch.fft.rfft(x, dim=-1, norm=\"backward\")  # pyright: ignore\n\n    def inverse(self, y: torch.Tensor) -&gt; torch.Tensor:\n        \"\"\"\n        Converts spectrogram into segments.\n\n        Args:\n            y (torch.Tensor): Spectrogram from a `forward` pass.\n\n        Returns:\n            torch.Tensor: Reconstructed segments.\n\n        \"\"\"\n        return torch.fft.irfft(y, dim=-1, norm=\"backward\")  # pyright: ignore\n</code></pre>"},{"location":"api/transforms/spectrogram/SpectrogramTorch/#libsegmenter.transforms.spectrogram.SpectrogramTorch.SpectrogramTorch.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the SpectrogramTorch instance.</p> Source code in <code>src/libsegmenter/transforms/spectrogram/SpectrogramTorch.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initializes the SpectrogramTorch instance.\"\"\"\n    return\n</code></pre>"},{"location":"api/transforms/spectrogram/SpectrogramTorch/#libsegmenter.transforms.spectrogram.SpectrogramTorch.SpectrogramTorch.forward","title":"<code>forward(x)</code>","text":"<p>Converts segments into a spectrogram.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>Input segments.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor: Spectrogram representation.</p> Source code in <code>src/libsegmenter/transforms/spectrogram/SpectrogramTorch.py</code> <pre><code>def forward(self, x: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"\n    Converts segments into a spectrogram.\n\n    Args:\n        x (torch.Tensor): Input segments.\n\n    Returns:\n        torch.Tensor: Spectrogram representation.\n\n    \"\"\"\n    if x.shape[-1] % 2 != 0:\n        raise ValueError(\n            \"Input segment size is expected to be even for a consistent definition \"\n            + \"of the inverse real-valued FFT.\"\n        )\n    return torch.fft.rfft(x, dim=-1, norm=\"backward\")  # pyright: ignore\n</code></pre>"},{"location":"api/transforms/spectrogram/SpectrogramTorch/#libsegmenter.transforms.spectrogram.SpectrogramTorch.SpectrogramTorch.inverse","title":"<code>inverse(y)</code>","text":"<p>Converts spectrogram into segments.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>Tensor</code> <p>Spectrogram from a <code>forward</code> pass.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor: Reconstructed segments.</p> Source code in <code>src/libsegmenter/transforms/spectrogram/SpectrogramTorch.py</code> <pre><code>def inverse(self, y: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"\n    Converts spectrogram into segments.\n\n    Args:\n        y (torch.Tensor): Spectrogram from a `forward` pass.\n\n    Returns:\n        torch.Tensor: Reconstructed segments.\n\n    \"\"\"\n    return torch.fft.irfft(y, dim=-1, norm=\"backward\")  # pyright: ignore\n</code></pre>"},{"location":"api/util/check_cola/","title":"check_cola","text":""},{"location":"api/util/check_cola/#libsegmenter.util.check_cola.check_cola","title":"<code>check_cola(window, hop_size, eps=1e-05)</code>","text":"<p>Checks the Constant Overlap Add (COLA) condition for a given window function.</p> <p>Parameters:</p> Name Type Description Default <code>window</code> <code>NDArray[T]</code> <p>The window samples.</p> required <code>hop_size</code> <code>int</code> <p>The hop size between frames.</p> required <code>eps</code> <code>float</code> <p>Tolerance for checking the COLA condition. Defaults to 1e-5.</p> <code>1e-05</code> <p>Returns:</p> Type Description <code>Tuple[bool, float, float]</code> <p>Tuple[bool, float, float]: A 3-tuple containing: (is_cola, normalization_value, epsilon)</p> Source code in <code>src/libsegmenter/util/check_cola.py</code> <pre><code>def check_cola(\n    window: NDArray[T], hop_size: int, eps: float = 1e-5\n) -&gt; Tuple[bool, float, float]:\n    \"\"\"\n    Checks the Constant Overlap Add (COLA) condition for a given window function.\n\n    Args:\n        window (NDArray[T]): The window samples.\n        hop_size (int): The hop size between frames.\n        eps (float): Tolerance for checking the COLA condition. Defaults to 1e-5.\n\n    Returns:\n        Tuple[bool, float, float]:\n            A 3-tuple containing:\n            (is_cola, normalization_value, epsilon)\n\n    \"\"\"\n    dc_value = float(np.sum(window, dtype=np.float32)) / hop_size\n    upper_bound = dc_value\n    lower_bound = dc_value\n\n    # loop over partial shifts\n    fundamental_freq = 1.0 / hop_size\n    for k in range(1, hop_size):\n        harmonic_freq = fundamental_freq * k\n\n        # complex sinusoids\n        csin = np.exp(1j * 2.0 * np.pi * harmonic_freq * np.arange(window.size))\n\n        # frequency domain representation of window\n        dft_coeff = np.sum(window * np.conjugate(csin))\n        upper_bound += np.abs(dft_coeff) / hop_size\n        lower_bound -= np.abs(dft_coeff) / hop_size\n\n    e = upper_bound - lower_bound\n    return (e &lt; eps, (upper_bound + lower_bound) / 2.0, e)\n</code></pre>"},{"location":"api/windows/bartlett50/","title":"bartlett50","text":"<p>Generates a Bartlett window of the given size with 50% overlap.</p> <p>Parameters:</p> Name Type Description Default <code>segment_size</code> <code>int</code> <p>Size of the window to be created.</p> required <code>dtype</code> <code>dtype</code> <p>The desired datatype of the window</p> <code>float32</code> <p>Returns:</p> Type Description <code>Tuple[NDArray[Any], int]</code> <p>A bartlett window with 50% overlap</p> Source code in <code>src/libsegmenter/windows/bartlett.py</code> <pre><code>def bartlett50(\n    segment_size: int, dtype: DTypeLike = np.float32\n) -&gt; Tuple[NDArray[Any], int]:\n    \"\"\"\n    Generates a Bartlett window of the given size with 50% overlap.\n\n    Args:\n        segment_size (int): Size of the window to be created.\n        dtype (np.dtype): The desired datatype of the window\n\n    Returns:\n        A bartlett window with 50% overlap\n\n    \"\"\"\n    assert segment_size % 2 == 0, f\"segment_size must be even, got {segment_size}\"\n\n    return _bartlett(segment_size, dtype=dtype), segment_size // 2\n</code></pre>"},{"location":"api/windows/bartlett75/","title":"bartlett75","text":"<p>Generates a Bartlett window of the given size with 75% overlap.</p> <p>Parameters:</p> Name Type Description Default <code>segment_size</code> <code>int</code> <p>Size of the window to be created.</p> required <code>dtype</code> <code>dtype</code> <p>The desired datatype of the window</p> <code>float32</code> <p>Returns:</p> Type Description <code>Tuple[NDArray[Any], int]</code> <p>A bartlett window with 75% overlap</p> Source code in <code>src/libsegmenter/windows/bartlett.py</code> <pre><code>def bartlett75(\n    segment_size: int, dtype: DTypeLike = np.float32\n) -&gt; Tuple[NDArray[Any], int]:\n    \"\"\"\n    Generates a Bartlett window of the given size with 75% overlap.\n\n    Args:\n        segment_size (int): Size of the window to be created.\n        dtype (np.dtype): The desired datatype of the window\n\n    Returns:\n        A bartlett window with 75% overlap\n\n    \"\"\"\n    assert segment_size % 4 == 0, f\"segment_size must be modulus 4, got {segment_size}\"\n\n    return _bartlett(segment_size, dtype=dtype), segment_size // 4\n</code></pre>"},{"location":"api/windows/blackman67/","title":"blackman67","text":"<p>Generates a Blackman window of the given size with a 2/3 overlap.</p> <p>Parameters:</p> Name Type Description Default <code>segment_size</code> <code>int</code> <p>Size of the window to be created.</p> required <code>dtype</code> <code>dtype</code> <p>The desired datatype of the window</p> <code>float32</code> <p>Returns:</p> Type Description <code>Tuple[NDArray[Any], int]</code> <p>A blackman window with a 2/3 overlap</p> Source code in <code>src/libsegmenter/windows/blackman.py</code> <pre><code>def blackman67(\n    segment_size: int, dtype: DTypeLike = np.float32\n) -&gt; Tuple[NDArray[Any], int]:\n    \"\"\"\n    Generates a Blackman window of the given size with a 2/3 overlap.\n\n    Args:\n        segment_size (int): Size of the window to be created.\n        dtype (np.dtype): The desired datatype of the window\n\n    Returns:\n        A blackman window with a 2/3 overlap\n\n    \"\"\"\n    assert segment_size % 3 == 0, f\"segment_size must be modulus 3, got {segment_size}\"\n\n    return _blackman(segment_size, dtype=dtype), segment_size // 3\n</code></pre>"},{"location":"api/windows/hamming50/","title":"hamming50","text":"<p>Generates a Hamming window of the given size with 50% overlap.</p> <p>Parameters:</p> Name Type Description Default <code>segment_size</code> <code>int</code> <p>Size of the window to be created.</p> required <code>dtype</code> <code>dtype</code> <p>The desired datatype of the window</p> <code>float32</code> <p>Returns:</p> Type Description <code>Tuple[NDArray[Any], int]</code> <p>A hamming window with 50% overlap</p> Source code in <code>src/libsegmenter/windows/hamming.py</code> <pre><code>def hamming50(\n    segment_size: int, dtype: DTypeLike = np.float32\n) -&gt; Tuple[NDArray[Any], int]:\n    \"\"\"\n    Generates a Hamming window of the given size with 50% overlap.\n\n    Args:\n        segment_size (int): Size of the window to be created.\n        dtype (np.dtype): The desired datatype of the window\n\n    Returns:\n        A hamming window with 50% overlap\n\n    \"\"\"\n    assert segment_size % 2 == 0, f\"segment_size must be even, got {segment_size}\"\n\n    return _hamming(segment_size, dtype=dtype), segment_size // 2\n</code></pre>"},{"location":"api/windows/hamming75/","title":"hamming75","text":"<p>Generates a Hamming window of the given size with 75% overlap.</p> <p>Parameters:</p> Name Type Description Default <code>segment_size</code> <code>int</code> <p>Size of the window to be created.</p> required <code>dtype</code> <code>dtype</code> <p>The desired datatype of the window</p> <code>float32</code> <p>Returns:</p> Type Description <code>Tuple[NDArray[Any], int]</code> <p>A hamming window with 75% overlap</p> Source code in <code>src/libsegmenter/windows/hamming.py</code> <pre><code>def hamming75(\n    segment_size: int, dtype: DTypeLike = np.float32\n) -&gt; Tuple[NDArray[Any], int]:\n    \"\"\"\n    Generates a Hamming window of the given size with 75% overlap.\n\n    Args:\n        segment_size (int): Size of the window to be created.\n        dtype (np.dtype): The desired datatype of the window\n\n    Returns:\n        A hamming window with 75% overlap\n\n    \"\"\"\n    assert segment_size % 4 == 0, f\"segment_size must be modulus 4, got {segment_size}\"\n\n    return _hamming(segment_size, dtype=dtype), segment_size // 4\n</code></pre>"},{"location":"api/windows/hann50/","title":"hann50","text":"<p>Generates a Hann window of the given size with 50% overlap.</p> <p>Parameters:</p> Name Type Description Default <code>segment_size</code> <code>int</code> <p>Size of the window to be created.</p> required <code>dtype</code> <code>dtype</code> <p>The desired datatype of the window</p> <code>float32</code> <p>Returns:</p> Type Description <code>Tuple[NDArray[Any], int]</code> <p>A hann window with 50% overlap</p> Source code in <code>src/libsegmenter/windows/hann.py</code> <pre><code>def hann50(\n    segment_size: int, dtype: DTypeLike = np.float32\n) -&gt; Tuple[NDArray[Any], int]:\n    \"\"\"\n    Generates a Hann window of the given size with 50% overlap.\n\n    Args:\n        segment_size (int): Size of the window to be created.\n        dtype (np.dtype): The desired datatype of the window\n\n    Returns:\n        A hann window with 50% overlap\n\n    \"\"\"\n    assert segment_size % 2 == 0, f\"segment_size must be even, got {segment_size}\"\n\n    indices = np.arange(segment_size, dtype=np.dtype(dtype).type)\n    return _hann(segment_size, indices, dtype=dtype), segment_size // 2\n</code></pre>"},{"location":"api/windows/hann75/","title":"hann75","text":"<p>Generates a Hann window of the given size with 75% overlap.</p> <p>Parameters:</p> Name Type Description Default <code>segment_size</code> <code>int</code> <p>Size of the window to be created.</p> required <code>dtype</code> <code>dtype</code> <p>The desired datatype of the window</p> <code>float32</code> <p>Returns:</p> Type Description <code>Tuple[NDArray[Any], int]</code> <p>A hann window with 75% overlap</p> Source code in <code>src/libsegmenter/windows/hann.py</code> <pre><code>def hann75(\n    segment_size: int, dtype: DTypeLike = np.float32\n) -&gt; Tuple[NDArray[Any], int]:\n    \"\"\"\n    Generates a Hann window of the given size with 75% overlap.\n\n    Args:\n        segment_size (int): Size of the window to be created.\n        dtype (np.dtype): The desired datatype of the window\n\n    Returns:\n        A hann window with 75% overlap\n\n    \"\"\"\n    assert segment_size % 4 == 0, f\"segment_size must be modulus 4, got {segment_size}\"\n\n    indices = np.arange(segment_size, dtype=np.dtype(dtype).type)\n    return _hann(segment_size, indices, dtype=dtype), segment_size // 4\n</code></pre>"},{"location":"api/windows/kaiser82/","title":"kaiser82","text":"<p>Generates a Kaiser window of the given size with 82% overlap.</p> <p>Parameters:</p> Name Type Description Default <code>segment_size</code> <code>int</code> <p>Size of the window to be created.</p> required <code>dtype</code> <code>dtype</code> <p>The desired datatype of the window</p> <code>float32</code> <p>Returns:</p> Type Description <code>Tuple[NDArray[Any], int]</code> <p>A kaiser window with 82% overlap</p> Source code in <code>src/libsegmenter/windows/kaiser.py</code> <pre><code>def kaiser82(\n    segment_size: int, dtype: DTypeLike = np.float32\n) -&gt; Tuple[NDArray[Any], int]:\n    \"\"\"\n    Generates a Kaiser window of the given size with 82% overlap.\n\n    Args:\n        segment_size (int): Size of the window to be created.\n        dtype (np.dtype): The desired datatype of the window\n\n    Returns:\n        A kaiser window with 82% overlap\n\n    \"\"\"\n    beta = 8.0\n    hop_size = _kaiser_hop_size(segment_size, beta)\n    return _kaiser(segment_size, beta, dtype=dtype), hop_size\n</code></pre>"},{"location":"api/windows/kaiser85/","title":"kaiser85","text":"<p>Generates a Kaiser window of the given size with 85% overlap.</p> <p>Parameters:</p> Name Type Description Default <code>segment_size</code> <code>int</code> <p>Size of the window to be created.</p> required <code>dtype</code> <code>dtype</code> <p>The desired datatype of the window</p> <code>float32</code> <p>Returns:</p> Type Description <code>Tuple[NDArray[Any], int]</code> <p>A kaiser window with 85% overlap</p> Source code in <code>src/libsegmenter/windows/kaiser.py</code> <pre><code>def kaiser85(\n    segment_size: int, dtype: DTypeLike = np.float32\n) -&gt; Tuple[NDArray[Any], int]:\n    \"\"\"\n    Generates a Kaiser window of the given size with 85% overlap.\n\n    Args:\n        segment_size (int): Size of the window to be created.\n        dtype (np.dtype): The desired datatype of the window\n\n    Returns:\n        A kaiser window with 85% overlap\n\n    \"\"\"\n    beta = 10.0\n    hop_size = _kaiser_hop_size(segment_size, beta)\n    return _kaiser(segment_size, beta, dtype=dtype), hop_size\n</code></pre>"},{"location":"api/windows/rectangular0/","title":"rectangular0","text":"<p>Generates a rectangular window of the given size with 0% overlap.</p> <p>Parameters:</p> Name Type Description Default <code>segment_size</code> <code>int</code> <p>Size of the window to be created.</p> required <code>dtype</code> <code>dtype</code> <p>The desired datatype of the window</p> <code>float32</code> <p>Returns:</p> Type Description <code>Tuple[NDArray[Any], int]</code> <p>A rectangular window with 0% overlap</p> Source code in <code>src/libsegmenter/windows/rectangular.py</code> <pre><code>def rectangular0(\n    segment_size: int, dtype: DTypeLike = np.float32\n) -&gt; Tuple[NDArray[Any], int]:\n    \"\"\"\n    Generates a rectangular window of the given size with 0% overlap.\n\n    Args:\n        segment_size (int): Size of the window to be created.\n        dtype (np.dtype): The desired datatype of the window\n\n    Returns:\n        A rectangular window with 0% overlap\n\n    \"\"\"\n    return _rectangular(segment_size, dtype=dtype), segment_size\n</code></pre>"},{"location":"api/windows/rectangular50/","title":"rectangular50","text":"<p>Generates a rectangular window of the given size with 50% overlap.</p> <p>Parameters:</p> Name Type Description Default <code>segment_size</code> <code>int</code> <p>Size of the window to be created.</p> required <code>dtype</code> <code>dtype</code> <p>The desired datatype of the window</p> <code>float32</code> <p>Returns:</p> Type Description <code>Tuple[NDArray[Any], int]</code> <p>A rectangular window with 50% overlap</p> Source code in <code>src/libsegmenter/windows/rectangular.py</code> <pre><code>def rectangular50(\n    segment_size: int, dtype: DTypeLike = np.float32\n) -&gt; Tuple[NDArray[Any], int]:\n    \"\"\"\n    Generates a rectangular window of the given size with 50% overlap.\n\n    Args:\n        segment_size (int): Size of the window to be created.\n        dtype (np.dtype): The desired datatype of the window\n\n    Returns:\n        A rectangular window with 50% overlap\n\n    \"\"\"\n    return _rectangular(segment_size, dtype=dtype), segment_size // 2\n</code></pre>"}]}