classdef BPDOctave < handle
    %BPDOctave
    % A class for computing the baseband phase difference transform
    properties
	magPhaseTransform = [];
    end

    methods
	function obj = BPDOctave()
	    % Initialize the BPD object.
    	    addpath('../magnitude/');
	    obj.magPhaseTransform = MagPhaseTransformOctave();
	end

	function [magnitude, bpd] = forward(obj, input, hopSize)
	    % Converts segments into a bpd.
	    %
	    % Args:
	    %    input (2D / 3D array): Segments as generated by a Segmenter object.
	    [magnitude, phase] = obj.magPhaseTransform.forward(input);
	    segmentSize = size(input, length(size(input))); 
	    frequency = 2*pi*(0:segmentSize-1)/segmentSize;
	    if length(size(input)) == 2
		bpd = angle(exp( 1j* ( phase - [zeros(1, segmentSize); phase(1:end-1,:)] - frequency * hopSize ) ));
	    else
		batchSize = size(input,1);
		numSegments = size(input,2);
		bpd = zeros(batchSize, numSegments, segmentSize);
		for bIdx = 1:batchSize
		    tmp = angle(exp( 1j* ( phase(bIdx,:,:) - [zeros(1, segmentSize); phase(bIdx, 1:end-1,:)] - frequency * hopSize ) ));
		    bpd(bIdx, :,:) = tmp;
		end
	    end
	end

	function sequence = inverse(obj, magnitude, bpd, hopSize)
	    % Convert magnitude and bpd into sequences.
	    segmentSize = size(magnitude, length(size(magnitude))); 
	    frequency = 2*pi*(0:segmentSize-1)/segmentSize;
	    if length(size(input)) == 2
		phase = angle(exp( 1j* cumsum( bpd + frequency*hopSize, 1 ) ));
	    else
		batchSize = size(input,1);
		numSegments = size(input,2);
		phase = zeros(batchSize, numSegments, segmentSize);
		for bIdx = 1:batchSize
		    tmp = angle(exp( 1j* cumsum( bpd + frequency*hopSize, 1 ) ));
		    phase(bIdx, :,:) = tmp;
		end
	    end
	    sequence = obj.magPhaseTransform.inverse(magnitude, phase);
	end
    end
end
